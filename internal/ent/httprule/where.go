// Code generated by entc, DO NOT EDIT.

package httprule

import (
	"go-gateway/internal/ent/predicate"

	"github.com/facebook/ent/dialect/sql"
)

// ID filters vertices based on their identifier.
func ID(id int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// ServiceID applies equality check predicate on the "service_id" field. It's identical to ServiceIDEQ.
func ServiceID(v int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldServiceID), v))
	})
}

// RuleType applies equality check predicate on the "rule_type" field. It's identical to RuleTypeEQ.
func RuleType(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRuleType), v))
	})
}

// Rule applies equality check predicate on the "rule" field. It's identical to RuleEQ.
func Rule(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRule), v))
	})
}

// NeedHTTPS applies equality check predicate on the "need_https" field. It's identical to NeedHTTPSEQ.
func NeedHTTPS(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeedHTTPS), v))
	})
}

// NeedWebsocket applies equality check predicate on the "need_websocket" field. It's identical to NeedWebsocketEQ.
func NeedWebsocket(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeedWebsocket), v))
	})
}

// NeedStripURI applies equality check predicate on the "need_strip_uri" field. It's identical to NeedStripURIEQ.
func NeedStripURI(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeedStripURI), v))
	})
}

// URLRewrite applies equality check predicate on the "url_rewrite" field. It's identical to URLRewriteEQ.
func URLRewrite(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldURLRewrite), v))
	})
}

// HeaderTransfor applies equality check predicate on the "header_transfor" field. It's identical to HeaderTransforEQ.
func HeaderTransfor(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHeaderTransfor), v))
	})
}

// ServiceIDEQ applies the EQ predicate on the "service_id" field.
func ServiceIDEQ(v int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldServiceID), v))
	})
}

// ServiceIDNEQ applies the NEQ predicate on the "service_id" field.
func ServiceIDNEQ(v int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldServiceID), v))
	})
}

// ServiceIDIn applies the In predicate on the "service_id" field.
func ServiceIDIn(vs ...int64) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldServiceID), v...))
	})
}

// ServiceIDNotIn applies the NotIn predicate on the "service_id" field.
func ServiceIDNotIn(vs ...int64) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldServiceID), v...))
	})
}

// ServiceIDGT applies the GT predicate on the "service_id" field.
func ServiceIDGT(v int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldServiceID), v))
	})
}

// ServiceIDGTE applies the GTE predicate on the "service_id" field.
func ServiceIDGTE(v int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldServiceID), v))
	})
}

// ServiceIDLT applies the LT predicate on the "service_id" field.
func ServiceIDLT(v int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldServiceID), v))
	})
}

// ServiceIDLTE applies the LTE predicate on the "service_id" field.
func ServiceIDLTE(v int64) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldServiceID), v))
	})
}

// RuleTypeEQ applies the EQ predicate on the "rule_type" field.
func RuleTypeEQ(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRuleType), v))
	})
}

// RuleTypeNEQ applies the NEQ predicate on the "rule_type" field.
func RuleTypeNEQ(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRuleType), v))
	})
}

// RuleTypeIn applies the In predicate on the "rule_type" field.
func RuleTypeIn(vs ...int) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRuleType), v...))
	})
}

// RuleTypeNotIn applies the NotIn predicate on the "rule_type" field.
func RuleTypeNotIn(vs ...int) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRuleType), v...))
	})
}

// RuleTypeGT applies the GT predicate on the "rule_type" field.
func RuleTypeGT(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRuleType), v))
	})
}

// RuleTypeGTE applies the GTE predicate on the "rule_type" field.
func RuleTypeGTE(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRuleType), v))
	})
}

// RuleTypeLT applies the LT predicate on the "rule_type" field.
func RuleTypeLT(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRuleType), v))
	})
}

// RuleTypeLTE applies the LTE predicate on the "rule_type" field.
func RuleTypeLTE(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRuleType), v))
	})
}

// RuleEQ applies the EQ predicate on the "rule" field.
func RuleEQ(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRule), v))
	})
}

// RuleNEQ applies the NEQ predicate on the "rule" field.
func RuleNEQ(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRule), v))
	})
}

// RuleIn applies the In predicate on the "rule" field.
func RuleIn(vs ...string) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRule), v...))
	})
}

// RuleNotIn applies the NotIn predicate on the "rule" field.
func RuleNotIn(vs ...string) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRule), v...))
	})
}

// RuleGT applies the GT predicate on the "rule" field.
func RuleGT(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRule), v))
	})
}

// RuleGTE applies the GTE predicate on the "rule" field.
func RuleGTE(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRule), v))
	})
}

// RuleLT applies the LT predicate on the "rule" field.
func RuleLT(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRule), v))
	})
}

// RuleLTE applies the LTE predicate on the "rule" field.
func RuleLTE(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRule), v))
	})
}

// RuleContains applies the Contains predicate on the "rule" field.
func RuleContains(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRule), v))
	})
}

// RuleHasPrefix applies the HasPrefix predicate on the "rule" field.
func RuleHasPrefix(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRule), v))
	})
}

// RuleHasSuffix applies the HasSuffix predicate on the "rule" field.
func RuleHasSuffix(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRule), v))
	})
}

// RuleEqualFold applies the EqualFold predicate on the "rule" field.
func RuleEqualFold(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRule), v))
	})
}

// RuleContainsFold applies the ContainsFold predicate on the "rule" field.
func RuleContainsFold(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRule), v))
	})
}

// NeedHTTPSEQ applies the EQ predicate on the "need_https" field.
func NeedHTTPSEQ(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeedHTTPS), v))
	})
}

// NeedHTTPSNEQ applies the NEQ predicate on the "need_https" field.
func NeedHTTPSNEQ(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNeedHTTPS), v))
	})
}

// NeedHTTPSIn applies the In predicate on the "need_https" field.
func NeedHTTPSIn(vs ...int) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldNeedHTTPS), v...))
	})
}

// NeedHTTPSNotIn applies the NotIn predicate on the "need_https" field.
func NeedHTTPSNotIn(vs ...int) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldNeedHTTPS), v...))
	})
}

// NeedHTTPSGT applies the GT predicate on the "need_https" field.
func NeedHTTPSGT(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldNeedHTTPS), v))
	})
}

// NeedHTTPSGTE applies the GTE predicate on the "need_https" field.
func NeedHTTPSGTE(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldNeedHTTPS), v))
	})
}

// NeedHTTPSLT applies the LT predicate on the "need_https" field.
func NeedHTTPSLT(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldNeedHTTPS), v))
	})
}

// NeedHTTPSLTE applies the LTE predicate on the "need_https" field.
func NeedHTTPSLTE(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldNeedHTTPS), v))
	})
}

// NeedWebsocketEQ applies the EQ predicate on the "need_websocket" field.
func NeedWebsocketEQ(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeedWebsocket), v))
	})
}

// NeedWebsocketNEQ applies the NEQ predicate on the "need_websocket" field.
func NeedWebsocketNEQ(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNeedWebsocket), v))
	})
}

// NeedWebsocketIn applies the In predicate on the "need_websocket" field.
func NeedWebsocketIn(vs ...int) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldNeedWebsocket), v...))
	})
}

// NeedWebsocketNotIn applies the NotIn predicate on the "need_websocket" field.
func NeedWebsocketNotIn(vs ...int) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldNeedWebsocket), v...))
	})
}

// NeedWebsocketGT applies the GT predicate on the "need_websocket" field.
func NeedWebsocketGT(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldNeedWebsocket), v))
	})
}

// NeedWebsocketGTE applies the GTE predicate on the "need_websocket" field.
func NeedWebsocketGTE(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldNeedWebsocket), v))
	})
}

// NeedWebsocketLT applies the LT predicate on the "need_websocket" field.
func NeedWebsocketLT(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldNeedWebsocket), v))
	})
}

// NeedWebsocketLTE applies the LTE predicate on the "need_websocket" field.
func NeedWebsocketLTE(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldNeedWebsocket), v))
	})
}

// NeedStripURIEQ applies the EQ predicate on the "need_strip_uri" field.
func NeedStripURIEQ(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeedStripURI), v))
	})
}

// NeedStripURINEQ applies the NEQ predicate on the "need_strip_uri" field.
func NeedStripURINEQ(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNeedStripURI), v))
	})
}

// NeedStripURIIn applies the In predicate on the "need_strip_uri" field.
func NeedStripURIIn(vs ...int) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldNeedStripURI), v...))
	})
}

// NeedStripURINotIn applies the NotIn predicate on the "need_strip_uri" field.
func NeedStripURINotIn(vs ...int) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldNeedStripURI), v...))
	})
}

// NeedStripURIGT applies the GT predicate on the "need_strip_uri" field.
func NeedStripURIGT(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldNeedStripURI), v))
	})
}

// NeedStripURIGTE applies the GTE predicate on the "need_strip_uri" field.
func NeedStripURIGTE(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldNeedStripURI), v))
	})
}

// NeedStripURILT applies the LT predicate on the "need_strip_uri" field.
func NeedStripURILT(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldNeedStripURI), v))
	})
}

// NeedStripURILTE applies the LTE predicate on the "need_strip_uri" field.
func NeedStripURILTE(v int) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldNeedStripURI), v))
	})
}

// URLRewriteEQ applies the EQ predicate on the "url_rewrite" field.
func URLRewriteEQ(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteNEQ applies the NEQ predicate on the "url_rewrite" field.
func URLRewriteNEQ(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteIn applies the In predicate on the "url_rewrite" field.
func URLRewriteIn(vs ...string) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldURLRewrite), v...))
	})
}

// URLRewriteNotIn applies the NotIn predicate on the "url_rewrite" field.
func URLRewriteNotIn(vs ...string) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldURLRewrite), v...))
	})
}

// URLRewriteGT applies the GT predicate on the "url_rewrite" field.
func URLRewriteGT(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteGTE applies the GTE predicate on the "url_rewrite" field.
func URLRewriteGTE(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteLT applies the LT predicate on the "url_rewrite" field.
func URLRewriteLT(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteLTE applies the LTE predicate on the "url_rewrite" field.
func URLRewriteLTE(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteContains applies the Contains predicate on the "url_rewrite" field.
func URLRewriteContains(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteHasPrefix applies the HasPrefix predicate on the "url_rewrite" field.
func URLRewriteHasPrefix(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteHasSuffix applies the HasSuffix predicate on the "url_rewrite" field.
func URLRewriteHasSuffix(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteEqualFold applies the EqualFold predicate on the "url_rewrite" field.
func URLRewriteEqualFold(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldURLRewrite), v))
	})
}

// URLRewriteContainsFold applies the ContainsFold predicate on the "url_rewrite" field.
func URLRewriteContainsFold(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldURLRewrite), v))
	})
}

// HeaderTransforEQ applies the EQ predicate on the "header_transfor" field.
func HeaderTransforEQ(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforNEQ applies the NEQ predicate on the "header_transfor" field.
func HeaderTransforNEQ(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforIn applies the In predicate on the "header_transfor" field.
func HeaderTransforIn(vs ...string) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHeaderTransfor), v...))
	})
}

// HeaderTransforNotIn applies the NotIn predicate on the "header_transfor" field.
func HeaderTransforNotIn(vs ...string) predicate.HttpRule {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.HttpRule(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHeaderTransfor), v...))
	})
}

// HeaderTransforGT applies the GT predicate on the "header_transfor" field.
func HeaderTransforGT(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforGTE applies the GTE predicate on the "header_transfor" field.
func HeaderTransforGTE(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforLT applies the LT predicate on the "header_transfor" field.
func HeaderTransforLT(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforLTE applies the LTE predicate on the "header_transfor" field.
func HeaderTransforLTE(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforContains applies the Contains predicate on the "header_transfor" field.
func HeaderTransforContains(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforHasPrefix applies the HasPrefix predicate on the "header_transfor" field.
func HeaderTransforHasPrefix(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforHasSuffix applies the HasSuffix predicate on the "header_transfor" field.
func HeaderTransforHasSuffix(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforEqualFold applies the EqualFold predicate on the "header_transfor" field.
func HeaderTransforEqualFold(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldHeaderTransfor), v))
	})
}

// HeaderTransforContainsFold applies the ContainsFold predicate on the "header_transfor" field.
func HeaderTransforContainsFold(v string) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldHeaderTransfor), v))
	})
}

// And groups list of predicates with the AND operator between them.
func And(predicates ...predicate.HttpRule) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups list of predicates with the OR operator between them.
func Or(predicates ...predicate.HttpRule) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.HttpRule) predicate.HttpRule {
	return predicate.HttpRule(func(s *sql.Selector) {
		p(s.Not())
	})
}
