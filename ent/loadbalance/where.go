// Code generated by entc, DO NOT EDIT.

package loadbalance

import (
	"go-gateway/ent/predicate"

	"github.com/facebook/ent/dialect/sql"
)

// ID filters vertices based on their identifier.
func ID(id int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// ServiceID applies equality check predicate on the "service_id" field. It's identical to ServiceIDEQ.
func ServiceID(v int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldServiceID), v))
	})
}

// CheckMethod applies equality check predicate on the "check_method" field. It's identical to CheckMethodEQ.
func CheckMethod(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCheckMethod), v))
	})
}

// CheckTimeout applies equality check predicate on the "check_timeout" field. It's identical to CheckTimeoutEQ.
func CheckTimeout(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCheckTimeout), v))
	})
}

// CheckInterval applies equality check predicate on the "check_interval" field. It's identical to CheckIntervalEQ.
func CheckInterval(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCheckInterval), v))
	})
}

// RoundType applies equality check predicate on the "round_type" field. It's identical to RoundTypeEQ.
func RoundType(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRoundType), v))
	})
}

// IPList applies equality check predicate on the "ip_list" field. It's identical to IPListEQ.
func IPList(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIPList), v))
	})
}

// WeightList applies equality check predicate on the "weight_list" field. It's identical to WeightListEQ.
func WeightList(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWeightList), v))
	})
}

// ForbidList applies equality check predicate on the "forbid_list" field. It's identical to ForbidListEQ.
func ForbidList(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldForbidList), v))
	})
}

// UpstreamConnectTimeout applies equality check predicate on the "upstream_connect_timeout" field. It's identical to UpstreamConnectTimeoutEQ.
func UpstreamConnectTimeout(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpstreamConnectTimeout), v))
	})
}

// UpstreamHeaderTimeout applies equality check predicate on the "upstream_header_timeout" field. It's identical to UpstreamHeaderTimeoutEQ.
func UpstreamHeaderTimeout(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpstreamHeaderTimeout), v))
	})
}

// UpstreamIdleTimeout applies equality check predicate on the "upstream_idle_timeout" field. It's identical to UpstreamIdleTimeoutEQ.
func UpstreamIdleTimeout(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpstreamIdleTimeout), v))
	})
}

// UpstreamMaxIdle applies equality check predicate on the "upstream_max_idle" field. It's identical to UpstreamMaxIdleEQ.
func UpstreamMaxIdle(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpstreamMaxIdle), v))
	})
}

// ServiceIDEQ applies the EQ predicate on the "service_id" field.
func ServiceIDEQ(v int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldServiceID), v))
	})
}

// ServiceIDNEQ applies the NEQ predicate on the "service_id" field.
func ServiceIDNEQ(v int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldServiceID), v))
	})
}

// ServiceIDIn applies the In predicate on the "service_id" field.
func ServiceIDIn(vs ...int64) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldServiceID), v...))
	})
}

// ServiceIDNotIn applies the NotIn predicate on the "service_id" field.
func ServiceIDNotIn(vs ...int64) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldServiceID), v...))
	})
}

// ServiceIDGT applies the GT predicate on the "service_id" field.
func ServiceIDGT(v int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldServiceID), v))
	})
}

// ServiceIDGTE applies the GTE predicate on the "service_id" field.
func ServiceIDGTE(v int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldServiceID), v))
	})
}

// ServiceIDLT applies the LT predicate on the "service_id" field.
func ServiceIDLT(v int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldServiceID), v))
	})
}

// ServiceIDLTE applies the LTE predicate on the "service_id" field.
func ServiceIDLTE(v int64) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldServiceID), v))
	})
}

// CheckMethodEQ applies the EQ predicate on the "check_method" field.
func CheckMethodEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCheckMethod), v))
	})
}

// CheckMethodNEQ applies the NEQ predicate on the "check_method" field.
func CheckMethodNEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCheckMethod), v))
	})
}

// CheckMethodIn applies the In predicate on the "check_method" field.
func CheckMethodIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCheckMethod), v...))
	})
}

// CheckMethodNotIn applies the NotIn predicate on the "check_method" field.
func CheckMethodNotIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCheckMethod), v...))
	})
}

// CheckMethodGT applies the GT predicate on the "check_method" field.
func CheckMethodGT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCheckMethod), v))
	})
}

// CheckMethodGTE applies the GTE predicate on the "check_method" field.
func CheckMethodGTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCheckMethod), v))
	})
}

// CheckMethodLT applies the LT predicate on the "check_method" field.
func CheckMethodLT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCheckMethod), v))
	})
}

// CheckMethodLTE applies the LTE predicate on the "check_method" field.
func CheckMethodLTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCheckMethod), v))
	})
}

// CheckTimeoutEQ applies the EQ predicate on the "check_timeout" field.
func CheckTimeoutEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCheckTimeout), v))
	})
}

// CheckTimeoutNEQ applies the NEQ predicate on the "check_timeout" field.
func CheckTimeoutNEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCheckTimeout), v))
	})
}

// CheckTimeoutIn applies the In predicate on the "check_timeout" field.
func CheckTimeoutIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCheckTimeout), v...))
	})
}

// CheckTimeoutNotIn applies the NotIn predicate on the "check_timeout" field.
func CheckTimeoutNotIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCheckTimeout), v...))
	})
}

// CheckTimeoutGT applies the GT predicate on the "check_timeout" field.
func CheckTimeoutGT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCheckTimeout), v))
	})
}

// CheckTimeoutGTE applies the GTE predicate on the "check_timeout" field.
func CheckTimeoutGTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCheckTimeout), v))
	})
}

// CheckTimeoutLT applies the LT predicate on the "check_timeout" field.
func CheckTimeoutLT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCheckTimeout), v))
	})
}

// CheckTimeoutLTE applies the LTE predicate on the "check_timeout" field.
func CheckTimeoutLTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCheckTimeout), v))
	})
}

// CheckIntervalEQ applies the EQ predicate on the "check_interval" field.
func CheckIntervalEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCheckInterval), v))
	})
}

// CheckIntervalNEQ applies the NEQ predicate on the "check_interval" field.
func CheckIntervalNEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCheckInterval), v))
	})
}

// CheckIntervalIn applies the In predicate on the "check_interval" field.
func CheckIntervalIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCheckInterval), v...))
	})
}

// CheckIntervalNotIn applies the NotIn predicate on the "check_interval" field.
func CheckIntervalNotIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCheckInterval), v...))
	})
}

// CheckIntervalGT applies the GT predicate on the "check_interval" field.
func CheckIntervalGT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCheckInterval), v))
	})
}

// CheckIntervalGTE applies the GTE predicate on the "check_interval" field.
func CheckIntervalGTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCheckInterval), v))
	})
}

// CheckIntervalLT applies the LT predicate on the "check_interval" field.
func CheckIntervalLT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCheckInterval), v))
	})
}

// CheckIntervalLTE applies the LTE predicate on the "check_interval" field.
func CheckIntervalLTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCheckInterval), v))
	})
}

// RoundTypeEQ applies the EQ predicate on the "round_type" field.
func RoundTypeEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRoundType), v))
	})
}

// RoundTypeNEQ applies the NEQ predicate on the "round_type" field.
func RoundTypeNEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRoundType), v))
	})
}

// RoundTypeIn applies the In predicate on the "round_type" field.
func RoundTypeIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRoundType), v...))
	})
}

// RoundTypeNotIn applies the NotIn predicate on the "round_type" field.
func RoundTypeNotIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRoundType), v...))
	})
}

// RoundTypeGT applies the GT predicate on the "round_type" field.
func RoundTypeGT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRoundType), v))
	})
}

// RoundTypeGTE applies the GTE predicate on the "round_type" field.
func RoundTypeGTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRoundType), v))
	})
}

// RoundTypeLT applies the LT predicate on the "round_type" field.
func RoundTypeLT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRoundType), v))
	})
}

// RoundTypeLTE applies the LTE predicate on the "round_type" field.
func RoundTypeLTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRoundType), v))
	})
}

// IPListEQ applies the EQ predicate on the "ip_list" field.
func IPListEQ(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIPList), v))
	})
}

// IPListNEQ applies the NEQ predicate on the "ip_list" field.
func IPListNEQ(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIPList), v))
	})
}

// IPListIn applies the In predicate on the "ip_list" field.
func IPListIn(vs ...string) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIPList), v...))
	})
}

// IPListNotIn applies the NotIn predicate on the "ip_list" field.
func IPListNotIn(vs ...string) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIPList), v...))
	})
}

// IPListGT applies the GT predicate on the "ip_list" field.
func IPListGT(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIPList), v))
	})
}

// IPListGTE applies the GTE predicate on the "ip_list" field.
func IPListGTE(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIPList), v))
	})
}

// IPListLT applies the LT predicate on the "ip_list" field.
func IPListLT(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIPList), v))
	})
}

// IPListLTE applies the LTE predicate on the "ip_list" field.
func IPListLTE(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIPList), v))
	})
}

// IPListContains applies the Contains predicate on the "ip_list" field.
func IPListContains(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldIPList), v))
	})
}

// IPListHasPrefix applies the HasPrefix predicate on the "ip_list" field.
func IPListHasPrefix(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldIPList), v))
	})
}

// IPListHasSuffix applies the HasSuffix predicate on the "ip_list" field.
func IPListHasSuffix(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldIPList), v))
	})
}

// IPListEqualFold applies the EqualFold predicate on the "ip_list" field.
func IPListEqualFold(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldIPList), v))
	})
}

// IPListContainsFold applies the ContainsFold predicate on the "ip_list" field.
func IPListContainsFold(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldIPList), v))
	})
}

// WeightListEQ applies the EQ predicate on the "weight_list" field.
func WeightListEQ(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWeightList), v))
	})
}

// WeightListNEQ applies the NEQ predicate on the "weight_list" field.
func WeightListNEQ(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWeightList), v))
	})
}

// WeightListIn applies the In predicate on the "weight_list" field.
func WeightListIn(vs ...string) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWeightList), v...))
	})
}

// WeightListNotIn applies the NotIn predicate on the "weight_list" field.
func WeightListNotIn(vs ...string) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWeightList), v...))
	})
}

// WeightListGT applies the GT predicate on the "weight_list" field.
func WeightListGT(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWeightList), v))
	})
}

// WeightListGTE applies the GTE predicate on the "weight_list" field.
func WeightListGTE(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWeightList), v))
	})
}

// WeightListLT applies the LT predicate on the "weight_list" field.
func WeightListLT(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWeightList), v))
	})
}

// WeightListLTE applies the LTE predicate on the "weight_list" field.
func WeightListLTE(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWeightList), v))
	})
}

// WeightListContains applies the Contains predicate on the "weight_list" field.
func WeightListContains(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldWeightList), v))
	})
}

// WeightListHasPrefix applies the HasPrefix predicate on the "weight_list" field.
func WeightListHasPrefix(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldWeightList), v))
	})
}

// WeightListHasSuffix applies the HasSuffix predicate on the "weight_list" field.
func WeightListHasSuffix(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldWeightList), v))
	})
}

// WeightListEqualFold applies the EqualFold predicate on the "weight_list" field.
func WeightListEqualFold(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldWeightList), v))
	})
}

// WeightListContainsFold applies the ContainsFold predicate on the "weight_list" field.
func WeightListContainsFold(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldWeightList), v))
	})
}

// ForbidListEQ applies the EQ predicate on the "forbid_list" field.
func ForbidListEQ(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldForbidList), v))
	})
}

// ForbidListNEQ applies the NEQ predicate on the "forbid_list" field.
func ForbidListNEQ(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldForbidList), v))
	})
}

// ForbidListIn applies the In predicate on the "forbid_list" field.
func ForbidListIn(vs ...string) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldForbidList), v...))
	})
}

// ForbidListNotIn applies the NotIn predicate on the "forbid_list" field.
func ForbidListNotIn(vs ...string) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldForbidList), v...))
	})
}

// ForbidListGT applies the GT predicate on the "forbid_list" field.
func ForbidListGT(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldForbidList), v))
	})
}

// ForbidListGTE applies the GTE predicate on the "forbid_list" field.
func ForbidListGTE(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldForbidList), v))
	})
}

// ForbidListLT applies the LT predicate on the "forbid_list" field.
func ForbidListLT(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldForbidList), v))
	})
}

// ForbidListLTE applies the LTE predicate on the "forbid_list" field.
func ForbidListLTE(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldForbidList), v))
	})
}

// ForbidListContains applies the Contains predicate on the "forbid_list" field.
func ForbidListContains(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldForbidList), v))
	})
}

// ForbidListHasPrefix applies the HasPrefix predicate on the "forbid_list" field.
func ForbidListHasPrefix(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldForbidList), v))
	})
}

// ForbidListHasSuffix applies the HasSuffix predicate on the "forbid_list" field.
func ForbidListHasSuffix(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldForbidList), v))
	})
}

// ForbidListEqualFold applies the EqualFold predicate on the "forbid_list" field.
func ForbidListEqualFold(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldForbidList), v))
	})
}

// ForbidListContainsFold applies the ContainsFold predicate on the "forbid_list" field.
func ForbidListContainsFold(v string) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldForbidList), v))
	})
}

// UpstreamConnectTimeoutEQ applies the EQ predicate on the "upstream_connect_timeout" field.
func UpstreamConnectTimeoutEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpstreamConnectTimeout), v))
	})
}

// UpstreamConnectTimeoutNEQ applies the NEQ predicate on the "upstream_connect_timeout" field.
func UpstreamConnectTimeoutNEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpstreamConnectTimeout), v))
	})
}

// UpstreamConnectTimeoutIn applies the In predicate on the "upstream_connect_timeout" field.
func UpstreamConnectTimeoutIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpstreamConnectTimeout), v...))
	})
}

// UpstreamConnectTimeoutNotIn applies the NotIn predicate on the "upstream_connect_timeout" field.
func UpstreamConnectTimeoutNotIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpstreamConnectTimeout), v...))
	})
}

// UpstreamConnectTimeoutGT applies the GT predicate on the "upstream_connect_timeout" field.
func UpstreamConnectTimeoutGT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpstreamConnectTimeout), v))
	})
}

// UpstreamConnectTimeoutGTE applies the GTE predicate on the "upstream_connect_timeout" field.
func UpstreamConnectTimeoutGTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpstreamConnectTimeout), v))
	})
}

// UpstreamConnectTimeoutLT applies the LT predicate on the "upstream_connect_timeout" field.
func UpstreamConnectTimeoutLT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpstreamConnectTimeout), v))
	})
}

// UpstreamConnectTimeoutLTE applies the LTE predicate on the "upstream_connect_timeout" field.
func UpstreamConnectTimeoutLTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpstreamConnectTimeout), v))
	})
}

// UpstreamHeaderTimeoutEQ applies the EQ predicate on the "upstream_header_timeout" field.
func UpstreamHeaderTimeoutEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpstreamHeaderTimeout), v))
	})
}

// UpstreamHeaderTimeoutNEQ applies the NEQ predicate on the "upstream_header_timeout" field.
func UpstreamHeaderTimeoutNEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpstreamHeaderTimeout), v))
	})
}

// UpstreamHeaderTimeoutIn applies the In predicate on the "upstream_header_timeout" field.
func UpstreamHeaderTimeoutIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpstreamHeaderTimeout), v...))
	})
}

// UpstreamHeaderTimeoutNotIn applies the NotIn predicate on the "upstream_header_timeout" field.
func UpstreamHeaderTimeoutNotIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpstreamHeaderTimeout), v...))
	})
}

// UpstreamHeaderTimeoutGT applies the GT predicate on the "upstream_header_timeout" field.
func UpstreamHeaderTimeoutGT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpstreamHeaderTimeout), v))
	})
}

// UpstreamHeaderTimeoutGTE applies the GTE predicate on the "upstream_header_timeout" field.
func UpstreamHeaderTimeoutGTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpstreamHeaderTimeout), v))
	})
}

// UpstreamHeaderTimeoutLT applies the LT predicate on the "upstream_header_timeout" field.
func UpstreamHeaderTimeoutLT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpstreamHeaderTimeout), v))
	})
}

// UpstreamHeaderTimeoutLTE applies the LTE predicate on the "upstream_header_timeout" field.
func UpstreamHeaderTimeoutLTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpstreamHeaderTimeout), v))
	})
}

// UpstreamIdleTimeoutEQ applies the EQ predicate on the "upstream_idle_timeout" field.
func UpstreamIdleTimeoutEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpstreamIdleTimeout), v))
	})
}

// UpstreamIdleTimeoutNEQ applies the NEQ predicate on the "upstream_idle_timeout" field.
func UpstreamIdleTimeoutNEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpstreamIdleTimeout), v))
	})
}

// UpstreamIdleTimeoutIn applies the In predicate on the "upstream_idle_timeout" field.
func UpstreamIdleTimeoutIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpstreamIdleTimeout), v...))
	})
}

// UpstreamIdleTimeoutNotIn applies the NotIn predicate on the "upstream_idle_timeout" field.
func UpstreamIdleTimeoutNotIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpstreamIdleTimeout), v...))
	})
}

// UpstreamIdleTimeoutGT applies the GT predicate on the "upstream_idle_timeout" field.
func UpstreamIdleTimeoutGT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpstreamIdleTimeout), v))
	})
}

// UpstreamIdleTimeoutGTE applies the GTE predicate on the "upstream_idle_timeout" field.
func UpstreamIdleTimeoutGTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpstreamIdleTimeout), v))
	})
}

// UpstreamIdleTimeoutLT applies the LT predicate on the "upstream_idle_timeout" field.
func UpstreamIdleTimeoutLT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpstreamIdleTimeout), v))
	})
}

// UpstreamIdleTimeoutLTE applies the LTE predicate on the "upstream_idle_timeout" field.
func UpstreamIdleTimeoutLTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpstreamIdleTimeout), v))
	})
}

// UpstreamMaxIdleEQ applies the EQ predicate on the "upstream_max_idle" field.
func UpstreamMaxIdleEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpstreamMaxIdle), v))
	})
}

// UpstreamMaxIdleNEQ applies the NEQ predicate on the "upstream_max_idle" field.
func UpstreamMaxIdleNEQ(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpstreamMaxIdle), v))
	})
}

// UpstreamMaxIdleIn applies the In predicate on the "upstream_max_idle" field.
func UpstreamMaxIdleIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpstreamMaxIdle), v...))
	})
}

// UpstreamMaxIdleNotIn applies the NotIn predicate on the "upstream_max_idle" field.
func UpstreamMaxIdleNotIn(vs ...int) predicate.LoadBalance {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.LoadBalance(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpstreamMaxIdle), v...))
	})
}

// UpstreamMaxIdleGT applies the GT predicate on the "upstream_max_idle" field.
func UpstreamMaxIdleGT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpstreamMaxIdle), v))
	})
}

// UpstreamMaxIdleGTE applies the GTE predicate on the "upstream_max_idle" field.
func UpstreamMaxIdleGTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpstreamMaxIdle), v))
	})
}

// UpstreamMaxIdleLT applies the LT predicate on the "upstream_max_idle" field.
func UpstreamMaxIdleLT(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpstreamMaxIdle), v))
	})
}

// UpstreamMaxIdleLTE applies the LTE predicate on the "upstream_max_idle" field.
func UpstreamMaxIdleLTE(v int) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpstreamMaxIdle), v))
	})
}

// And groups list of predicates with the AND operator between them.
func And(predicates ...predicate.LoadBalance) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups list of predicates with the OR operator between them.
func Or(predicates ...predicate.LoadBalance) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.LoadBalance) predicate.LoadBalance {
	return predicate.LoadBalance(func(s *sql.Selector) {
		p(s.Not())
	})
}
