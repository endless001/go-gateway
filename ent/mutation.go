// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"go-gateway/ent/accesscontrol"
	"go-gateway/ent/app"
	"go-gateway/ent/grpcrule"
	"go-gateway/ent/httprule"
	"go-gateway/ent/loadbalance"
	"go-gateway/ent/predicate"
	"go-gateway/ent/service"
	"go-gateway/ent/tcprule"
	"go-gateway/ent/user"
	"sync"
	"time"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessControl = "AccessControl"
	TypeApp           = "App"
	TypeGrpcRule      = "GrpcRule"
	TypeHttpRule      = "HttpRule"
	TypeLoadBalance   = "LoadBalance"
	TypeService       = "Service"
	TypeTcpRule       = "TcpRule"
	TypeUser          = "User"
)

// AccessControlMutation represents an operation that mutate the AccessControls
// nodes in the graph.
type AccessControlMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	service_id             *int64
	addservice_id          *int64
	open_auth              *int
	addopen_auth           *int
	black_list             *string
	white_list             *string
	white_host_name        *string
	clientip_flow_limit    *int
	addclientip_flow_limit *int
	service_flow_limit     *int
	addservice_flow_limit  *int
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*AccessControl, error)
	predicates             []predicate.AccessControl
}

var _ ent.Mutation = (*AccessControlMutation)(nil)

// accesscontrolOption allows to manage the mutation configuration using functional options.
type accesscontrolOption func(*AccessControlMutation)

// newAccessControlMutation creates new mutation for $n.Name.
func newAccessControlMutation(c config, op Op, opts ...accesscontrolOption) *AccessControlMutation {
	m := &AccessControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessControlID sets the id field of the mutation.
func withAccessControlID(id int64) accesscontrolOption {
	return func(m *AccessControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessControl
		)
		m.oldValue = func(ctx context.Context) (*AccessControl, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessControl sets the old AccessControl of the mutation.
func withAccessControl(node *AccessControl) accesscontrolOption {
	return func(m *AccessControlMutation) {
		m.oldValue = func(context.Context) (*AccessControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on AccessControl creation.
func (m *AccessControlMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AccessControlMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetServiceID sets the service_id field.
func (m *AccessControlMutation) SetServiceID(i int64) {
	m.service_id = &i
	m.addservice_id = nil
}

// ServiceID returns the service_id value in the mutation.
func (m *AccessControlMutation) ServiceID() (r int64, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old service_id value of the AccessControl.
// If the AccessControl object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccessControlMutation) OldServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// AddServiceID adds i to service_id.
func (m *AccessControlMutation) AddServiceID(i int64) {
	if m.addservice_id != nil {
		*m.addservice_id += i
	} else {
		m.addservice_id = &i
	}
}

// AddedServiceID returns the value that was added to the service_id field in this mutation.
func (m *AccessControlMutation) AddedServiceID() (r int64, exists bool) {
	v := m.addservice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetServiceID reset all changes of the "service_id" field.
func (m *AccessControlMutation) ResetServiceID() {
	m.service_id = nil
	m.addservice_id = nil
}

// SetOpenAuth sets the open_auth field.
func (m *AccessControlMutation) SetOpenAuth(i int) {
	m.open_auth = &i
	m.addopen_auth = nil
}

// OpenAuth returns the open_auth value in the mutation.
func (m *AccessControlMutation) OpenAuth() (r int, exists bool) {
	v := m.open_auth
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenAuth returns the old open_auth value of the AccessControl.
// If the AccessControl object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccessControlMutation) OldOpenAuth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpenAuth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpenAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenAuth: %w", err)
	}
	return oldValue.OpenAuth, nil
}

// AddOpenAuth adds i to open_auth.
func (m *AccessControlMutation) AddOpenAuth(i int) {
	if m.addopen_auth != nil {
		*m.addopen_auth += i
	} else {
		m.addopen_auth = &i
	}
}

// AddedOpenAuth returns the value that was added to the open_auth field in this mutation.
func (m *AccessControlMutation) AddedOpenAuth() (r int, exists bool) {
	v := m.addopen_auth
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpenAuth reset all changes of the "open_auth" field.
func (m *AccessControlMutation) ResetOpenAuth() {
	m.open_auth = nil
	m.addopen_auth = nil
}

// SetBlackList sets the black_list field.
func (m *AccessControlMutation) SetBlackList(s string) {
	m.black_list = &s
}

// BlackList returns the black_list value in the mutation.
func (m *AccessControlMutation) BlackList() (r string, exists bool) {
	v := m.black_list
	if v == nil {
		return
	}
	return *v, true
}

// OldBlackList returns the old black_list value of the AccessControl.
// If the AccessControl object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccessControlMutation) OldBlackList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBlackList is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBlackList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlackList: %w", err)
	}
	return oldValue.BlackList, nil
}

// ResetBlackList reset all changes of the "black_list" field.
func (m *AccessControlMutation) ResetBlackList() {
	m.black_list = nil
}

// SetWhiteList sets the white_list field.
func (m *AccessControlMutation) SetWhiteList(s string) {
	m.white_list = &s
}

// WhiteList returns the white_list value in the mutation.
func (m *AccessControlMutation) WhiteList() (r string, exists bool) {
	v := m.white_list
	if v == nil {
		return
	}
	return *v, true
}

// OldWhiteList returns the old white_list value of the AccessControl.
// If the AccessControl object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccessControlMutation) OldWhiteList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWhiteList is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWhiteList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhiteList: %w", err)
	}
	return oldValue.WhiteList, nil
}

// ResetWhiteList reset all changes of the "white_list" field.
func (m *AccessControlMutation) ResetWhiteList() {
	m.white_list = nil
}

// SetWhiteHostName sets the white_host_name field.
func (m *AccessControlMutation) SetWhiteHostName(s string) {
	m.white_host_name = &s
}

// WhiteHostName returns the white_host_name value in the mutation.
func (m *AccessControlMutation) WhiteHostName() (r string, exists bool) {
	v := m.white_host_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWhiteHostName returns the old white_host_name value of the AccessControl.
// If the AccessControl object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccessControlMutation) OldWhiteHostName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWhiteHostName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWhiteHostName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhiteHostName: %w", err)
	}
	return oldValue.WhiteHostName, nil
}

// ResetWhiteHostName reset all changes of the "white_host_name" field.
func (m *AccessControlMutation) ResetWhiteHostName() {
	m.white_host_name = nil
}

// SetClientipFlowLimit sets the clientip_flow_limit field.
func (m *AccessControlMutation) SetClientipFlowLimit(i int) {
	m.clientip_flow_limit = &i
	m.addclientip_flow_limit = nil
}

// ClientipFlowLimit returns the clientip_flow_limit value in the mutation.
func (m *AccessControlMutation) ClientipFlowLimit() (r int, exists bool) {
	v := m.clientip_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldClientipFlowLimit returns the old clientip_flow_limit value of the AccessControl.
// If the AccessControl object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccessControlMutation) OldClientipFlowLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClientipFlowLimit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClientipFlowLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientipFlowLimit: %w", err)
	}
	return oldValue.ClientipFlowLimit, nil
}

// AddClientipFlowLimit adds i to clientip_flow_limit.
func (m *AccessControlMutation) AddClientipFlowLimit(i int) {
	if m.addclientip_flow_limit != nil {
		*m.addclientip_flow_limit += i
	} else {
		m.addclientip_flow_limit = &i
	}
}

// AddedClientipFlowLimit returns the value that was added to the clientip_flow_limit field in this mutation.
func (m *AccessControlMutation) AddedClientipFlowLimit() (r int, exists bool) {
	v := m.addclientip_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientipFlowLimit reset all changes of the "clientip_flow_limit" field.
func (m *AccessControlMutation) ResetClientipFlowLimit() {
	m.clientip_flow_limit = nil
	m.addclientip_flow_limit = nil
}

// SetServiceFlowLimit sets the service_flow_limit field.
func (m *AccessControlMutation) SetServiceFlowLimit(i int) {
	m.service_flow_limit = &i
	m.addservice_flow_limit = nil
}

// ServiceFlowLimit returns the service_flow_limit value in the mutation.
func (m *AccessControlMutation) ServiceFlowLimit() (r int, exists bool) {
	v := m.service_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceFlowLimit returns the old service_flow_limit value of the AccessControl.
// If the AccessControl object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccessControlMutation) OldServiceFlowLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceFlowLimit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceFlowLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceFlowLimit: %w", err)
	}
	return oldValue.ServiceFlowLimit, nil
}

// AddServiceFlowLimit adds i to service_flow_limit.
func (m *AccessControlMutation) AddServiceFlowLimit(i int) {
	if m.addservice_flow_limit != nil {
		*m.addservice_flow_limit += i
	} else {
		m.addservice_flow_limit = &i
	}
}

// AddedServiceFlowLimit returns the value that was added to the service_flow_limit field in this mutation.
func (m *AccessControlMutation) AddedServiceFlowLimit() (r int, exists bool) {
	v := m.addservice_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetServiceFlowLimit reset all changes of the "service_flow_limit" field.
func (m *AccessControlMutation) ResetServiceFlowLimit() {
	m.service_flow_limit = nil
	m.addservice_flow_limit = nil
}

// Op returns the operation name.
func (m *AccessControlMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccessControl).
func (m *AccessControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AccessControlMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.service_id != nil {
		fields = append(fields, accesscontrol.FieldServiceID)
	}
	if m.open_auth != nil {
		fields = append(fields, accesscontrol.FieldOpenAuth)
	}
	if m.black_list != nil {
		fields = append(fields, accesscontrol.FieldBlackList)
	}
	if m.white_list != nil {
		fields = append(fields, accesscontrol.FieldWhiteList)
	}
	if m.white_host_name != nil {
		fields = append(fields, accesscontrol.FieldWhiteHostName)
	}
	if m.clientip_flow_limit != nil {
		fields = append(fields, accesscontrol.FieldClientipFlowLimit)
	}
	if m.service_flow_limit != nil {
		fields = append(fields, accesscontrol.FieldServiceFlowLimit)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AccessControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accesscontrol.FieldServiceID:
		return m.ServiceID()
	case accesscontrol.FieldOpenAuth:
		return m.OpenAuth()
	case accesscontrol.FieldBlackList:
		return m.BlackList()
	case accesscontrol.FieldWhiteList:
		return m.WhiteList()
	case accesscontrol.FieldWhiteHostName:
		return m.WhiteHostName()
	case accesscontrol.FieldClientipFlowLimit:
		return m.ClientipFlowLimit()
	case accesscontrol.FieldServiceFlowLimit:
		return m.ServiceFlowLimit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AccessControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accesscontrol.FieldServiceID:
		return m.OldServiceID(ctx)
	case accesscontrol.FieldOpenAuth:
		return m.OldOpenAuth(ctx)
	case accesscontrol.FieldBlackList:
		return m.OldBlackList(ctx)
	case accesscontrol.FieldWhiteList:
		return m.OldWhiteList(ctx)
	case accesscontrol.FieldWhiteHostName:
		return m.OldWhiteHostName(ctx)
	case accesscontrol.FieldClientipFlowLimit:
		return m.OldClientipFlowLimit(ctx)
	case accesscontrol.FieldServiceFlowLimit:
		return m.OldServiceFlowLimit(ctx)
	}
	return nil, fmt.Errorf("unknown AccessControl field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AccessControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accesscontrol.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case accesscontrol.FieldOpenAuth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenAuth(v)
		return nil
	case accesscontrol.FieldBlackList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlackList(v)
		return nil
	case accesscontrol.FieldWhiteList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhiteList(v)
		return nil
	case accesscontrol.FieldWhiteHostName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhiteHostName(v)
		return nil
	case accesscontrol.FieldClientipFlowLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientipFlowLimit(v)
		return nil
	case accesscontrol.FieldServiceFlowLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceFlowLimit(v)
		return nil
	}
	return fmt.Errorf("unknown AccessControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AccessControlMutation) AddedFields() []string {
	var fields []string
	if m.addservice_id != nil {
		fields = append(fields, accesscontrol.FieldServiceID)
	}
	if m.addopen_auth != nil {
		fields = append(fields, accesscontrol.FieldOpenAuth)
	}
	if m.addclientip_flow_limit != nil {
		fields = append(fields, accesscontrol.FieldClientipFlowLimit)
	}
	if m.addservice_flow_limit != nil {
		fields = append(fields, accesscontrol.FieldServiceFlowLimit)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AccessControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accesscontrol.FieldServiceID:
		return m.AddedServiceID()
	case accesscontrol.FieldOpenAuth:
		return m.AddedOpenAuth()
	case accesscontrol.FieldClientipFlowLimit:
		return m.AddedClientipFlowLimit()
	case accesscontrol.FieldServiceFlowLimit:
		return m.AddedServiceFlowLimit()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AccessControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accesscontrol.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceID(v)
		return nil
	case accesscontrol.FieldOpenAuth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpenAuth(v)
		return nil
	case accesscontrol.FieldClientipFlowLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientipFlowLimit(v)
		return nil
	case accesscontrol.FieldServiceFlowLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceFlowLimit(v)
		return nil
	}
	return fmt.Errorf("unknown AccessControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AccessControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AccessControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccessControl nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AccessControlMutation) ResetField(name string) error {
	switch name {
	case accesscontrol.FieldServiceID:
		m.ResetServiceID()
		return nil
	case accesscontrol.FieldOpenAuth:
		m.ResetOpenAuth()
		return nil
	case accesscontrol.FieldBlackList:
		m.ResetBlackList()
		return nil
	case accesscontrol.FieldWhiteList:
		m.ResetWhiteList()
		return nil
	case accesscontrol.FieldWhiteHostName:
		m.ResetWhiteHostName()
		return nil
	case accesscontrol.FieldClientipFlowLimit:
		m.ResetClientipFlowLimit()
		return nil
	case accesscontrol.FieldServiceFlowLimit:
		m.ResetServiceFlowLimit()
		return nil
	}
	return fmt.Errorf("unknown AccessControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AccessControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AccessControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AccessControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AccessControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AccessControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AccessControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AccessControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccessControl unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AccessControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccessControl edge %s", name)
}

// AppMutation represents an operation that mutate the Apps
// nodes in the graph.
type AppMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	app_id        *string
	name          *string
	secret        *string
	white_ips     *string
	qpd           *int
	addqpd        *int
	_Qps          *int
	add_Qps       *int
	create_at     *time.Time
	update_at     *time.Time
	is_delete     *int8
	addis_delete  *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*App, error)
	predicates    []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows to manage the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for $n.Name.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the id field of the mutation.
func withAppID(id int64) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on App creation.
func (m *AppMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AppMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAppID sets the app_id field.
func (m *AppMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the app_id value in the mutation.
func (m *AppMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old app_id value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID reset all changes of the "app_id" field.
func (m *AppMutation) ResetAppID() {
	m.app_id = nil
}

// SetName sets the name field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetSecret sets the secret field.
func (m *AppMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the secret value in the mutation.
func (m *AppMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old secret value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecret is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret reset all changes of the "secret" field.
func (m *AppMutation) ResetSecret() {
	m.secret = nil
}

// SetWhiteIps sets the white_ips field.
func (m *AppMutation) SetWhiteIps(s string) {
	m.white_ips = &s
}

// WhiteIps returns the white_ips value in the mutation.
func (m *AppMutation) WhiteIps() (r string, exists bool) {
	v := m.white_ips
	if v == nil {
		return
	}
	return *v, true
}

// OldWhiteIps returns the old white_ips value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldWhiteIps(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWhiteIps is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWhiteIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhiteIps: %w", err)
	}
	return oldValue.WhiteIps, nil
}

// ResetWhiteIps reset all changes of the "white_ips" field.
func (m *AppMutation) ResetWhiteIps() {
	m.white_ips = nil
}

// SetQpd sets the qpd field.
func (m *AppMutation) SetQpd(i int) {
	m.qpd = &i
	m.addqpd = nil
}

// Qpd returns the qpd value in the mutation.
func (m *AppMutation) Qpd() (r int, exists bool) {
	v := m.qpd
	if v == nil {
		return
	}
	return *v, true
}

// OldQpd returns the old qpd value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldQpd(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQpd is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQpd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQpd: %w", err)
	}
	return oldValue.Qpd, nil
}

// AddQpd adds i to qpd.
func (m *AppMutation) AddQpd(i int) {
	if m.addqpd != nil {
		*m.addqpd += i
	} else {
		m.addqpd = &i
	}
}

// AddedQpd returns the value that was added to the qpd field in this mutation.
func (m *AppMutation) AddedQpd() (r int, exists bool) {
	v := m.addqpd
	if v == nil {
		return
	}
	return *v, true
}

// ResetQpd reset all changes of the "qpd" field.
func (m *AppMutation) ResetQpd() {
	m.qpd = nil
	m.addqpd = nil
}

// SetQPS sets the Qps field.
func (m *AppMutation) SetQPS(i int) {
	m._Qps = &i
	m.add_Qps = nil
}

// QPS returns the Qps value in the mutation.
func (m *AppMutation) QPS() (r int, exists bool) {
	v := m._Qps
	if v == nil {
		return
	}
	return *v, true
}

// OldQPS returns the old Qps value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldQPS(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQPS is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQPS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQPS: %w", err)
	}
	return oldValue.QPS, nil
}

// AddQPS adds i to Qps.
func (m *AppMutation) AddQPS(i int) {
	if m.add_Qps != nil {
		*m.add_Qps += i
	} else {
		m.add_Qps = &i
	}
}

// AddedQPS returns the value that was added to the Qps field in this mutation.
func (m *AppMutation) AddedQPS() (r int, exists bool) {
	v := m.add_Qps
	if v == nil {
		return
	}
	return *v, true
}

// ResetQPS reset all changes of the "Qps" field.
func (m *AppMutation) ResetQPS() {
	m._Qps = nil
	m.add_Qps = nil
}

// SetCreateAt sets the create_at field.
func (m *AppMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the create_at value in the mutation.
func (m *AppMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old create_at value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt reset all changes of the "create_at" field.
func (m *AppMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the update_at field.
func (m *AppMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the update_at value in the mutation.
func (m *AppMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old update_at value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt reset all changes of the "update_at" field.
func (m *AppMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetIsDelete sets the is_delete field.
func (m *AppMutation) SetIsDelete(i int8) {
	m.is_delete = &i
	m.addis_delete = nil
}

// IsDelete returns the is_delete value in the mutation.
func (m *AppMutation) IsDelete() (r int8, exists bool) {
	v := m.is_delete
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDelete returns the old is_delete value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldIsDelete(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDelete is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDelete: %w", err)
	}
	return oldValue.IsDelete, nil
}

// AddIsDelete adds i to is_delete.
func (m *AppMutation) AddIsDelete(i int8) {
	if m.addis_delete != nil {
		*m.addis_delete += i
	} else {
		m.addis_delete = &i
	}
}

// AddedIsDelete returns the value that was added to the is_delete field in this mutation.
func (m *AppMutation) AddedIsDelete() (r int8, exists bool) {
	v := m.addis_delete
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDelete reset all changes of the "is_delete" field.
func (m *AppMutation) ResetIsDelete() {
	m.is_delete = nil
	m.addis_delete = nil
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.app_id != nil {
		fields = append(fields, app.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.secret != nil {
		fields = append(fields, app.FieldSecret)
	}
	if m.white_ips != nil {
		fields = append(fields, app.FieldWhiteIps)
	}
	if m.qpd != nil {
		fields = append(fields, app.FieldQpd)
	}
	if m._Qps != nil {
		fields = append(fields, app.FieldQPS)
	}
	if m.create_at != nil {
		fields = append(fields, app.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, app.FieldUpdateAt)
	}
	if m.is_delete != nil {
		fields = append(fields, app.FieldIsDelete)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldAppID:
		return m.AppID()
	case app.FieldName:
		return m.Name()
	case app.FieldSecret:
		return m.Secret()
	case app.FieldWhiteIps:
		return m.WhiteIps()
	case app.FieldQpd:
		return m.Qpd()
	case app.FieldQPS:
		return m.QPS()
	case app.FieldCreateAt:
		return m.CreateAt()
	case app.FieldUpdateAt:
		return m.UpdateAt()
	case app.FieldIsDelete:
		return m.IsDelete()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldAppID:
		return m.OldAppID(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldSecret:
		return m.OldSecret(ctx)
	case app.FieldWhiteIps:
		return m.OldWhiteIps(ctx)
	case app.FieldQpd:
		return m.OldQpd(ctx)
	case app.FieldQPS:
		return m.OldQPS(ctx)
	case app.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case app.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case app.FieldIsDelete:
		return m.OldIsDelete(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case app.FieldWhiteIps:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhiteIps(v)
		return nil
	case app.FieldQpd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQpd(v)
		return nil
	case app.FieldQPS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQPS(v)
		return nil
	case app.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case app.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case app.FieldIsDelete:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDelete(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addqpd != nil {
		fields = append(fields, app.FieldQpd)
	}
	if m.add_Qps != nil {
		fields = append(fields, app.FieldQPS)
	}
	if m.addis_delete != nil {
		fields = append(fields, app.FieldIsDelete)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldQpd:
		return m.AddedQpd()
	case app.FieldQPS:
		return m.AddedQPS()
	case app.FieldIsDelete:
		return m.AddedIsDelete()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldQpd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQpd(v)
		return nil
	case app.FieldQPS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQPS(v)
		return nil
	case app.FieldIsDelete:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDelete(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldAppID:
		m.ResetAppID()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldSecret:
		m.ResetSecret()
		return nil
	case app.FieldWhiteIps:
		m.ResetWhiteIps()
		return nil
	case app.FieldQpd:
		m.ResetQpd()
		return nil
	case app.FieldQPS:
		m.ResetQPS()
		return nil
	case app.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case app.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case app.FieldIsDelete:
		m.ResetIsDelete()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown App edge %s", name)
}

// GrpcRuleMutation represents an operation that mutate the GrpcRules
// nodes in the graph.
type GrpcRuleMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	service_id      *int64
	addservice_id   *int64
	_Port           *int
	add_Port        *int
	header_transfor *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*GrpcRule, error)
	predicates      []predicate.GrpcRule
}

var _ ent.Mutation = (*GrpcRuleMutation)(nil)

// grpcruleOption allows to manage the mutation configuration using functional options.
type grpcruleOption func(*GrpcRuleMutation)

// newGrpcRuleMutation creates new mutation for $n.Name.
func newGrpcRuleMutation(c config, op Op, opts ...grpcruleOption) *GrpcRuleMutation {
	m := &GrpcRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeGrpcRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrpcRuleID sets the id field of the mutation.
func withGrpcRuleID(id int64) grpcruleOption {
	return func(m *GrpcRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *GrpcRule
		)
		m.oldValue = func(ctx context.Context) (*GrpcRule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GrpcRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrpcRule sets the old GrpcRule of the mutation.
func withGrpcRule(node *GrpcRule) grpcruleOption {
	return func(m *GrpcRuleMutation) {
		m.oldValue = func(context.Context) (*GrpcRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrpcRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrpcRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on GrpcRule creation.
func (m *GrpcRuleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GrpcRuleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetServiceID sets the service_id field.
func (m *GrpcRuleMutation) SetServiceID(i int64) {
	m.service_id = &i
	m.addservice_id = nil
}

// ServiceID returns the service_id value in the mutation.
func (m *GrpcRuleMutation) ServiceID() (r int64, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old service_id value of the GrpcRule.
// If the GrpcRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GrpcRuleMutation) OldServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// AddServiceID adds i to service_id.
func (m *GrpcRuleMutation) AddServiceID(i int64) {
	if m.addservice_id != nil {
		*m.addservice_id += i
	} else {
		m.addservice_id = &i
	}
}

// AddedServiceID returns the value that was added to the service_id field in this mutation.
func (m *GrpcRuleMutation) AddedServiceID() (r int64, exists bool) {
	v := m.addservice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetServiceID reset all changes of the "service_id" field.
func (m *GrpcRuleMutation) ResetServiceID() {
	m.service_id = nil
	m.addservice_id = nil
}

// SetPort sets the Port field.
func (m *GrpcRuleMutation) SetPort(i int) {
	m._Port = &i
	m.add_Port = nil
}

// Port returns the Port value in the mutation.
func (m *GrpcRuleMutation) Port() (r int, exists bool) {
	v := m._Port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old Port value of the GrpcRule.
// If the GrpcRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GrpcRuleMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to Port.
func (m *GrpcRuleMutation) AddPort(i int) {
	if m.add_Port != nil {
		*m.add_Port += i
	} else {
		m.add_Port = &i
	}
}

// AddedPort returns the value that was added to the Port field in this mutation.
func (m *GrpcRuleMutation) AddedPort() (r int, exists bool) {
	v := m.add_Port
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort reset all changes of the "Port" field.
func (m *GrpcRuleMutation) ResetPort() {
	m._Port = nil
	m.add_Port = nil
}

// SetHeaderTransfor sets the header_transfor field.
func (m *GrpcRuleMutation) SetHeaderTransfor(s string) {
	m.header_transfor = &s
}

// HeaderTransfor returns the header_transfor value in the mutation.
func (m *GrpcRuleMutation) HeaderTransfor() (r string, exists bool) {
	v := m.header_transfor
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaderTransfor returns the old header_transfor value of the GrpcRule.
// If the GrpcRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GrpcRuleMutation) OldHeaderTransfor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeaderTransfor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeaderTransfor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaderTransfor: %w", err)
	}
	return oldValue.HeaderTransfor, nil
}

// ResetHeaderTransfor reset all changes of the "header_transfor" field.
func (m *GrpcRuleMutation) ResetHeaderTransfor() {
	m.header_transfor = nil
}

// Op returns the operation name.
func (m *GrpcRuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GrpcRule).
func (m *GrpcRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GrpcRuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.service_id != nil {
		fields = append(fields, grpcrule.FieldServiceID)
	}
	if m._Port != nil {
		fields = append(fields, grpcrule.FieldPort)
	}
	if m.header_transfor != nil {
		fields = append(fields, grpcrule.FieldHeaderTransfor)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GrpcRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grpcrule.FieldServiceID:
		return m.ServiceID()
	case grpcrule.FieldPort:
		return m.Port()
	case grpcrule.FieldHeaderTransfor:
		return m.HeaderTransfor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GrpcRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grpcrule.FieldServiceID:
		return m.OldServiceID(ctx)
	case grpcrule.FieldPort:
		return m.OldPort(ctx)
	case grpcrule.FieldHeaderTransfor:
		return m.OldHeaderTransfor(ctx)
	}
	return nil, fmt.Errorf("unknown GrpcRule field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GrpcRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grpcrule.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case grpcrule.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case grpcrule.FieldHeaderTransfor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaderTransfor(v)
		return nil
	}
	return fmt.Errorf("unknown GrpcRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GrpcRuleMutation) AddedFields() []string {
	var fields []string
	if m.addservice_id != nil {
		fields = append(fields, grpcrule.FieldServiceID)
	}
	if m.add_Port != nil {
		fields = append(fields, grpcrule.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GrpcRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case grpcrule.FieldServiceID:
		return m.AddedServiceID()
	case grpcrule.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GrpcRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case grpcrule.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceID(v)
		return nil
	case grpcrule.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown GrpcRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GrpcRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GrpcRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrpcRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GrpcRule nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GrpcRuleMutation) ResetField(name string) error {
	switch name {
	case grpcrule.FieldServiceID:
		m.ResetServiceID()
		return nil
	case grpcrule.FieldPort:
		m.ResetPort()
		return nil
	case grpcrule.FieldHeaderTransfor:
		m.ResetHeaderTransfor()
		return nil
	}
	return fmt.Errorf("unknown GrpcRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GrpcRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GrpcRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GrpcRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GrpcRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GrpcRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GrpcRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GrpcRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GrpcRule unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GrpcRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GrpcRule edge %s", name)
}

// HttpRuleMutation represents an operation that mutate the HttpRules
// nodes in the graph.
type HttpRuleMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	service_id        *int64
	addservice_id     *int64
	rule_type         *int
	addrule_type      *int
	rule              *string
	need_https        *int
	addneed_https     *int
	need_websocket    *int
	addneed_websocket *int
	need_strip_uri    *int
	addneed_strip_uri *int
	url_rewrite       *string
	header_transfor   *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*HttpRule, error)
	predicates        []predicate.HttpRule
}

var _ ent.Mutation = (*HttpRuleMutation)(nil)

// httpruleOption allows to manage the mutation configuration using functional options.
type httpruleOption func(*HttpRuleMutation)

// newHttpRuleMutation creates new mutation for $n.Name.
func newHttpRuleMutation(c config, op Op, opts ...httpruleOption) *HttpRuleMutation {
	m := &HttpRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeHttpRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHttpRuleID sets the id field of the mutation.
func withHttpRuleID(id int64) httpruleOption {
	return func(m *HttpRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *HttpRule
		)
		m.oldValue = func(ctx context.Context) (*HttpRule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HttpRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHttpRule sets the old HttpRule of the mutation.
func withHttpRule(node *HttpRule) httpruleOption {
	return func(m *HttpRuleMutation) {
		m.oldValue = func(context.Context) (*HttpRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HttpRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HttpRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on HttpRule creation.
func (m *HttpRuleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HttpRuleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetServiceID sets the service_id field.
func (m *HttpRuleMutation) SetServiceID(i int64) {
	m.service_id = &i
	m.addservice_id = nil
}

// ServiceID returns the service_id value in the mutation.
func (m *HttpRuleMutation) ServiceID() (r int64, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old service_id value of the HttpRule.
// If the HttpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HttpRuleMutation) OldServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// AddServiceID adds i to service_id.
func (m *HttpRuleMutation) AddServiceID(i int64) {
	if m.addservice_id != nil {
		*m.addservice_id += i
	} else {
		m.addservice_id = &i
	}
}

// AddedServiceID returns the value that was added to the service_id field in this mutation.
func (m *HttpRuleMutation) AddedServiceID() (r int64, exists bool) {
	v := m.addservice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetServiceID reset all changes of the "service_id" field.
func (m *HttpRuleMutation) ResetServiceID() {
	m.service_id = nil
	m.addservice_id = nil
}

// SetRuleType sets the rule_type field.
func (m *HttpRuleMutation) SetRuleType(i int) {
	m.rule_type = &i
	m.addrule_type = nil
}

// RuleType returns the rule_type value in the mutation.
func (m *HttpRuleMutation) RuleType() (r int, exists bool) {
	v := m.rule_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleType returns the old rule_type value of the HttpRule.
// If the HttpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HttpRuleMutation) OldRuleType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRuleType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRuleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleType: %w", err)
	}
	return oldValue.RuleType, nil
}

// AddRuleType adds i to rule_type.
func (m *HttpRuleMutation) AddRuleType(i int) {
	if m.addrule_type != nil {
		*m.addrule_type += i
	} else {
		m.addrule_type = &i
	}
}

// AddedRuleType returns the value that was added to the rule_type field in this mutation.
func (m *HttpRuleMutation) AddedRuleType() (r int, exists bool) {
	v := m.addrule_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetRuleType reset all changes of the "rule_type" field.
func (m *HttpRuleMutation) ResetRuleType() {
	m.rule_type = nil
	m.addrule_type = nil
}

// SetRule sets the rule field.
func (m *HttpRuleMutation) SetRule(s string) {
	m.rule = &s
}

// Rule returns the rule value in the mutation.
func (m *HttpRuleMutation) Rule() (r string, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRule returns the old rule value of the HttpRule.
// If the HttpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HttpRuleMutation) OldRule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRule is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRule: %w", err)
	}
	return oldValue.Rule, nil
}

// ResetRule reset all changes of the "rule" field.
func (m *HttpRuleMutation) ResetRule() {
	m.rule = nil
}

// SetNeedHTTPS sets the need_https field.
func (m *HttpRuleMutation) SetNeedHTTPS(i int) {
	m.need_https = &i
	m.addneed_https = nil
}

// NeedHTTPS returns the need_https value in the mutation.
func (m *HttpRuleMutation) NeedHTTPS() (r int, exists bool) {
	v := m.need_https
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedHTTPS returns the old need_https value of the HttpRule.
// If the HttpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HttpRuleMutation) OldNeedHTTPS(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNeedHTTPS is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNeedHTTPS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedHTTPS: %w", err)
	}
	return oldValue.NeedHTTPS, nil
}

// AddNeedHTTPS adds i to need_https.
func (m *HttpRuleMutation) AddNeedHTTPS(i int) {
	if m.addneed_https != nil {
		*m.addneed_https += i
	} else {
		m.addneed_https = &i
	}
}

// AddedNeedHTTPS returns the value that was added to the need_https field in this mutation.
func (m *HttpRuleMutation) AddedNeedHTTPS() (r int, exists bool) {
	v := m.addneed_https
	if v == nil {
		return
	}
	return *v, true
}

// ResetNeedHTTPS reset all changes of the "need_https" field.
func (m *HttpRuleMutation) ResetNeedHTTPS() {
	m.need_https = nil
	m.addneed_https = nil
}

// SetNeedWebsocket sets the need_websocket field.
func (m *HttpRuleMutation) SetNeedWebsocket(i int) {
	m.need_websocket = &i
	m.addneed_websocket = nil
}

// NeedWebsocket returns the need_websocket value in the mutation.
func (m *HttpRuleMutation) NeedWebsocket() (r int, exists bool) {
	v := m.need_websocket
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedWebsocket returns the old need_websocket value of the HttpRule.
// If the HttpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HttpRuleMutation) OldNeedWebsocket(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNeedWebsocket is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNeedWebsocket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedWebsocket: %w", err)
	}
	return oldValue.NeedWebsocket, nil
}

// AddNeedWebsocket adds i to need_websocket.
func (m *HttpRuleMutation) AddNeedWebsocket(i int) {
	if m.addneed_websocket != nil {
		*m.addneed_websocket += i
	} else {
		m.addneed_websocket = &i
	}
}

// AddedNeedWebsocket returns the value that was added to the need_websocket field in this mutation.
func (m *HttpRuleMutation) AddedNeedWebsocket() (r int, exists bool) {
	v := m.addneed_websocket
	if v == nil {
		return
	}
	return *v, true
}

// ResetNeedWebsocket reset all changes of the "need_websocket" field.
func (m *HttpRuleMutation) ResetNeedWebsocket() {
	m.need_websocket = nil
	m.addneed_websocket = nil
}

// SetNeedStripURI sets the need_strip_uri field.
func (m *HttpRuleMutation) SetNeedStripURI(i int) {
	m.need_strip_uri = &i
	m.addneed_strip_uri = nil
}

// NeedStripURI returns the need_strip_uri value in the mutation.
func (m *HttpRuleMutation) NeedStripURI() (r int, exists bool) {
	v := m.need_strip_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedStripURI returns the old need_strip_uri value of the HttpRule.
// If the HttpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HttpRuleMutation) OldNeedStripURI(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNeedStripURI is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNeedStripURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedStripURI: %w", err)
	}
	return oldValue.NeedStripURI, nil
}

// AddNeedStripURI adds i to need_strip_uri.
func (m *HttpRuleMutation) AddNeedStripURI(i int) {
	if m.addneed_strip_uri != nil {
		*m.addneed_strip_uri += i
	} else {
		m.addneed_strip_uri = &i
	}
}

// AddedNeedStripURI returns the value that was added to the need_strip_uri field in this mutation.
func (m *HttpRuleMutation) AddedNeedStripURI() (r int, exists bool) {
	v := m.addneed_strip_uri
	if v == nil {
		return
	}
	return *v, true
}

// ResetNeedStripURI reset all changes of the "need_strip_uri" field.
func (m *HttpRuleMutation) ResetNeedStripURI() {
	m.need_strip_uri = nil
	m.addneed_strip_uri = nil
}

// SetURLRewrite sets the url_rewrite field.
func (m *HttpRuleMutation) SetURLRewrite(s string) {
	m.url_rewrite = &s
}

// URLRewrite returns the url_rewrite value in the mutation.
func (m *HttpRuleMutation) URLRewrite() (r string, exists bool) {
	v := m.url_rewrite
	if v == nil {
		return
	}
	return *v, true
}

// OldURLRewrite returns the old url_rewrite value of the HttpRule.
// If the HttpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HttpRuleMutation) OldURLRewrite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURLRewrite is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURLRewrite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLRewrite: %w", err)
	}
	return oldValue.URLRewrite, nil
}

// ResetURLRewrite reset all changes of the "url_rewrite" field.
func (m *HttpRuleMutation) ResetURLRewrite() {
	m.url_rewrite = nil
}

// SetHeaderTransfor sets the header_transfor field.
func (m *HttpRuleMutation) SetHeaderTransfor(s string) {
	m.header_transfor = &s
}

// HeaderTransfor returns the header_transfor value in the mutation.
func (m *HttpRuleMutation) HeaderTransfor() (r string, exists bool) {
	v := m.header_transfor
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaderTransfor returns the old header_transfor value of the HttpRule.
// If the HttpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HttpRuleMutation) OldHeaderTransfor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeaderTransfor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeaderTransfor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaderTransfor: %w", err)
	}
	return oldValue.HeaderTransfor, nil
}

// ResetHeaderTransfor reset all changes of the "header_transfor" field.
func (m *HttpRuleMutation) ResetHeaderTransfor() {
	m.header_transfor = nil
}

// Op returns the operation name.
func (m *HttpRuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HttpRule).
func (m *HttpRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HttpRuleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.service_id != nil {
		fields = append(fields, httprule.FieldServiceID)
	}
	if m.rule_type != nil {
		fields = append(fields, httprule.FieldRuleType)
	}
	if m.rule != nil {
		fields = append(fields, httprule.FieldRule)
	}
	if m.need_https != nil {
		fields = append(fields, httprule.FieldNeedHTTPS)
	}
	if m.need_websocket != nil {
		fields = append(fields, httprule.FieldNeedWebsocket)
	}
	if m.need_strip_uri != nil {
		fields = append(fields, httprule.FieldNeedStripURI)
	}
	if m.url_rewrite != nil {
		fields = append(fields, httprule.FieldURLRewrite)
	}
	if m.header_transfor != nil {
		fields = append(fields, httprule.FieldHeaderTransfor)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HttpRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case httprule.FieldServiceID:
		return m.ServiceID()
	case httprule.FieldRuleType:
		return m.RuleType()
	case httprule.FieldRule:
		return m.Rule()
	case httprule.FieldNeedHTTPS:
		return m.NeedHTTPS()
	case httprule.FieldNeedWebsocket:
		return m.NeedWebsocket()
	case httprule.FieldNeedStripURI:
		return m.NeedStripURI()
	case httprule.FieldURLRewrite:
		return m.URLRewrite()
	case httprule.FieldHeaderTransfor:
		return m.HeaderTransfor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HttpRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case httprule.FieldServiceID:
		return m.OldServiceID(ctx)
	case httprule.FieldRuleType:
		return m.OldRuleType(ctx)
	case httprule.FieldRule:
		return m.OldRule(ctx)
	case httprule.FieldNeedHTTPS:
		return m.OldNeedHTTPS(ctx)
	case httprule.FieldNeedWebsocket:
		return m.OldNeedWebsocket(ctx)
	case httprule.FieldNeedStripURI:
		return m.OldNeedStripURI(ctx)
	case httprule.FieldURLRewrite:
		return m.OldURLRewrite(ctx)
	case httprule.FieldHeaderTransfor:
		return m.OldHeaderTransfor(ctx)
	}
	return nil, fmt.Errorf("unknown HttpRule field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HttpRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case httprule.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case httprule.FieldRuleType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleType(v)
		return nil
	case httprule.FieldRule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRule(v)
		return nil
	case httprule.FieldNeedHTTPS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedHTTPS(v)
		return nil
	case httprule.FieldNeedWebsocket:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedWebsocket(v)
		return nil
	case httprule.FieldNeedStripURI:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedStripURI(v)
		return nil
	case httprule.FieldURLRewrite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLRewrite(v)
		return nil
	case httprule.FieldHeaderTransfor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaderTransfor(v)
		return nil
	}
	return fmt.Errorf("unknown HttpRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HttpRuleMutation) AddedFields() []string {
	var fields []string
	if m.addservice_id != nil {
		fields = append(fields, httprule.FieldServiceID)
	}
	if m.addrule_type != nil {
		fields = append(fields, httprule.FieldRuleType)
	}
	if m.addneed_https != nil {
		fields = append(fields, httprule.FieldNeedHTTPS)
	}
	if m.addneed_websocket != nil {
		fields = append(fields, httprule.FieldNeedWebsocket)
	}
	if m.addneed_strip_uri != nil {
		fields = append(fields, httprule.FieldNeedStripURI)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HttpRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case httprule.FieldServiceID:
		return m.AddedServiceID()
	case httprule.FieldRuleType:
		return m.AddedRuleType()
	case httprule.FieldNeedHTTPS:
		return m.AddedNeedHTTPS()
	case httprule.FieldNeedWebsocket:
		return m.AddedNeedWebsocket()
	case httprule.FieldNeedStripURI:
		return m.AddedNeedStripURI()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HttpRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case httprule.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceID(v)
		return nil
	case httprule.FieldRuleType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRuleType(v)
		return nil
	case httprule.FieldNeedHTTPS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNeedHTTPS(v)
		return nil
	case httprule.FieldNeedWebsocket:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNeedWebsocket(v)
		return nil
	case httprule.FieldNeedStripURI:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNeedStripURI(v)
		return nil
	}
	return fmt.Errorf("unknown HttpRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HttpRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HttpRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HttpRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HttpRule nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HttpRuleMutation) ResetField(name string) error {
	switch name {
	case httprule.FieldServiceID:
		m.ResetServiceID()
		return nil
	case httprule.FieldRuleType:
		m.ResetRuleType()
		return nil
	case httprule.FieldRule:
		m.ResetRule()
		return nil
	case httprule.FieldNeedHTTPS:
		m.ResetNeedHTTPS()
		return nil
	case httprule.FieldNeedWebsocket:
		m.ResetNeedWebsocket()
		return nil
	case httprule.FieldNeedStripURI:
		m.ResetNeedStripURI()
		return nil
	case httprule.FieldURLRewrite:
		m.ResetURLRewrite()
		return nil
	case httprule.FieldHeaderTransfor:
		m.ResetHeaderTransfor()
		return nil
	}
	return fmt.Errorf("unknown HttpRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HttpRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HttpRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HttpRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HttpRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HttpRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HttpRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HttpRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HttpRule unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HttpRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HttpRule edge %s", name)
}

// LoadBalanceMutation represents an operation that mutate the LoadBalances
// nodes in the graph.
type LoadBalanceMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	service_id                  *int64
	addservice_id               *int64
	check_method                *int
	addcheck_method             *int
	check_timeout               *int
	addcheck_timeout            *int
	check_interval              *int
	addcheck_interval           *int
	round_type                  *int
	addround_type               *int
	ip_list                     *string
	weight_list                 *string
	forbid_list                 *string
	upstream_connect_timeout    *int
	addupstream_connect_timeout *int
	upstream_header_timeout     *int
	addupstream_header_timeout  *int
	upstream_idle_timeout       *int
	addupstream_idle_timeout    *int
	upstream_max_idle           *int
	addupstream_max_idle        *int
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*LoadBalance, error)
	predicates                  []predicate.LoadBalance
}

var _ ent.Mutation = (*LoadBalanceMutation)(nil)

// loadbalanceOption allows to manage the mutation configuration using functional options.
type loadbalanceOption func(*LoadBalanceMutation)

// newLoadBalanceMutation creates new mutation for $n.Name.
func newLoadBalanceMutation(c config, op Op, opts ...loadbalanceOption) *LoadBalanceMutation {
	m := &LoadBalanceMutation{
		config:        c,
		op:            op,
		typ:           TypeLoadBalance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoadBalanceID sets the id field of the mutation.
func withLoadBalanceID(id int64) loadbalanceOption {
	return func(m *LoadBalanceMutation) {
		var (
			err   error
			once  sync.Once
			value *LoadBalance
		)
		m.oldValue = func(ctx context.Context) (*LoadBalance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoadBalance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoadBalance sets the old LoadBalance of the mutation.
func withLoadBalance(node *LoadBalance) loadbalanceOption {
	return func(m *LoadBalanceMutation) {
		m.oldValue = func(context.Context) (*LoadBalance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoadBalanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoadBalanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on LoadBalance creation.
func (m *LoadBalanceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LoadBalanceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetServiceID sets the service_id field.
func (m *LoadBalanceMutation) SetServiceID(i int64) {
	m.service_id = &i
	m.addservice_id = nil
}

// ServiceID returns the service_id value in the mutation.
func (m *LoadBalanceMutation) ServiceID() (r int64, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old service_id value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// AddServiceID adds i to service_id.
func (m *LoadBalanceMutation) AddServiceID(i int64) {
	if m.addservice_id != nil {
		*m.addservice_id += i
	} else {
		m.addservice_id = &i
	}
}

// AddedServiceID returns the value that was added to the service_id field in this mutation.
func (m *LoadBalanceMutation) AddedServiceID() (r int64, exists bool) {
	v := m.addservice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetServiceID reset all changes of the "service_id" field.
func (m *LoadBalanceMutation) ResetServiceID() {
	m.service_id = nil
	m.addservice_id = nil
}

// SetCheckMethod sets the check_method field.
func (m *LoadBalanceMutation) SetCheckMethod(i int) {
	m.check_method = &i
	m.addcheck_method = nil
}

// CheckMethod returns the check_method value in the mutation.
func (m *LoadBalanceMutation) CheckMethod() (r int, exists bool) {
	v := m.check_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckMethod returns the old check_method value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldCheckMethod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckMethod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckMethod: %w", err)
	}
	return oldValue.CheckMethod, nil
}

// AddCheckMethod adds i to check_method.
func (m *LoadBalanceMutation) AddCheckMethod(i int) {
	if m.addcheck_method != nil {
		*m.addcheck_method += i
	} else {
		m.addcheck_method = &i
	}
}

// AddedCheckMethod returns the value that was added to the check_method field in this mutation.
func (m *LoadBalanceMutation) AddedCheckMethod() (r int, exists bool) {
	v := m.addcheck_method
	if v == nil {
		return
	}
	return *v, true
}

// ResetCheckMethod reset all changes of the "check_method" field.
func (m *LoadBalanceMutation) ResetCheckMethod() {
	m.check_method = nil
	m.addcheck_method = nil
}

// SetCheckTimeout sets the check_timeout field.
func (m *LoadBalanceMutation) SetCheckTimeout(i int) {
	m.check_timeout = &i
	m.addcheck_timeout = nil
}

// CheckTimeout returns the check_timeout value in the mutation.
func (m *LoadBalanceMutation) CheckTimeout() (r int, exists bool) {
	v := m.check_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckTimeout returns the old check_timeout value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldCheckTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckTimeout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckTimeout: %w", err)
	}
	return oldValue.CheckTimeout, nil
}

// AddCheckTimeout adds i to check_timeout.
func (m *LoadBalanceMutation) AddCheckTimeout(i int) {
	if m.addcheck_timeout != nil {
		*m.addcheck_timeout += i
	} else {
		m.addcheck_timeout = &i
	}
}

// AddedCheckTimeout returns the value that was added to the check_timeout field in this mutation.
func (m *LoadBalanceMutation) AddedCheckTimeout() (r int, exists bool) {
	v := m.addcheck_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetCheckTimeout reset all changes of the "check_timeout" field.
func (m *LoadBalanceMutation) ResetCheckTimeout() {
	m.check_timeout = nil
	m.addcheck_timeout = nil
}

// SetCheckInterval sets the check_interval field.
func (m *LoadBalanceMutation) SetCheckInterval(i int) {
	m.check_interval = &i
	m.addcheck_interval = nil
}

// CheckInterval returns the check_interval value in the mutation.
func (m *LoadBalanceMutation) CheckInterval() (r int, exists bool) {
	v := m.check_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInterval returns the old check_interval value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldCheckInterval(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckInterval is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInterval: %w", err)
	}
	return oldValue.CheckInterval, nil
}

// AddCheckInterval adds i to check_interval.
func (m *LoadBalanceMutation) AddCheckInterval(i int) {
	if m.addcheck_interval != nil {
		*m.addcheck_interval += i
	} else {
		m.addcheck_interval = &i
	}
}

// AddedCheckInterval returns the value that was added to the check_interval field in this mutation.
func (m *LoadBalanceMutation) AddedCheckInterval() (r int, exists bool) {
	v := m.addcheck_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetCheckInterval reset all changes of the "check_interval" field.
func (m *LoadBalanceMutation) ResetCheckInterval() {
	m.check_interval = nil
	m.addcheck_interval = nil
}

// SetRoundType sets the round_type field.
func (m *LoadBalanceMutation) SetRoundType(i int) {
	m.round_type = &i
	m.addround_type = nil
}

// RoundType returns the round_type value in the mutation.
func (m *LoadBalanceMutation) RoundType() (r int, exists bool) {
	v := m.round_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundType returns the old round_type value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldRoundType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoundType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoundType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundType: %w", err)
	}
	return oldValue.RoundType, nil
}

// AddRoundType adds i to round_type.
func (m *LoadBalanceMutation) AddRoundType(i int) {
	if m.addround_type != nil {
		*m.addround_type += i
	} else {
		m.addround_type = &i
	}
}

// AddedRoundType returns the value that was added to the round_type field in this mutation.
func (m *LoadBalanceMutation) AddedRoundType() (r int, exists bool) {
	v := m.addround_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundType reset all changes of the "round_type" field.
func (m *LoadBalanceMutation) ResetRoundType() {
	m.round_type = nil
	m.addround_type = nil
}

// SetIPList sets the ip_list field.
func (m *LoadBalanceMutation) SetIPList(s string) {
	m.ip_list = &s
}

// IPList returns the ip_list value in the mutation.
func (m *LoadBalanceMutation) IPList() (r string, exists bool) {
	v := m.ip_list
	if v == nil {
		return
	}
	return *v, true
}

// OldIPList returns the old ip_list value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldIPList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIPList is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIPList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPList: %w", err)
	}
	return oldValue.IPList, nil
}

// ResetIPList reset all changes of the "ip_list" field.
func (m *LoadBalanceMutation) ResetIPList() {
	m.ip_list = nil
}

// SetWeightList sets the weight_list field.
func (m *LoadBalanceMutation) SetWeightList(s string) {
	m.weight_list = &s
}

// WeightList returns the weight_list value in the mutation.
func (m *LoadBalanceMutation) WeightList() (r string, exists bool) {
	v := m.weight_list
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightList returns the old weight_list value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldWeightList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeightList is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeightList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightList: %w", err)
	}
	return oldValue.WeightList, nil
}

// ResetWeightList reset all changes of the "weight_list" field.
func (m *LoadBalanceMutation) ResetWeightList() {
	m.weight_list = nil
}

// SetForbidList sets the forbid_list field.
func (m *LoadBalanceMutation) SetForbidList(s string) {
	m.forbid_list = &s
}

// ForbidList returns the forbid_list value in the mutation.
func (m *LoadBalanceMutation) ForbidList() (r string, exists bool) {
	v := m.forbid_list
	if v == nil {
		return
	}
	return *v, true
}

// OldForbidList returns the old forbid_list value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldForbidList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldForbidList is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldForbidList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForbidList: %w", err)
	}
	return oldValue.ForbidList, nil
}

// ResetForbidList reset all changes of the "forbid_list" field.
func (m *LoadBalanceMutation) ResetForbidList() {
	m.forbid_list = nil
}

// SetUpstreamConnectTimeout sets the upstream_connect_timeout field.
func (m *LoadBalanceMutation) SetUpstreamConnectTimeout(i int) {
	m.upstream_connect_timeout = &i
	m.addupstream_connect_timeout = nil
}

// UpstreamConnectTimeout returns the upstream_connect_timeout value in the mutation.
func (m *LoadBalanceMutation) UpstreamConnectTimeout() (r int, exists bool) {
	v := m.upstream_connect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldUpstreamConnectTimeout returns the old upstream_connect_timeout value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldUpstreamConnectTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpstreamConnectTimeout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpstreamConnectTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpstreamConnectTimeout: %w", err)
	}
	return oldValue.UpstreamConnectTimeout, nil
}

// AddUpstreamConnectTimeout adds i to upstream_connect_timeout.
func (m *LoadBalanceMutation) AddUpstreamConnectTimeout(i int) {
	if m.addupstream_connect_timeout != nil {
		*m.addupstream_connect_timeout += i
	} else {
		m.addupstream_connect_timeout = &i
	}
}

// AddedUpstreamConnectTimeout returns the value that was added to the upstream_connect_timeout field in this mutation.
func (m *LoadBalanceMutation) AddedUpstreamConnectTimeout() (r int, exists bool) {
	v := m.addupstream_connect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpstreamConnectTimeout reset all changes of the "upstream_connect_timeout" field.
func (m *LoadBalanceMutation) ResetUpstreamConnectTimeout() {
	m.upstream_connect_timeout = nil
	m.addupstream_connect_timeout = nil
}

// SetUpstreamHeaderTimeout sets the upstream_header_timeout field.
func (m *LoadBalanceMutation) SetUpstreamHeaderTimeout(i int) {
	m.upstream_header_timeout = &i
	m.addupstream_header_timeout = nil
}

// UpstreamHeaderTimeout returns the upstream_header_timeout value in the mutation.
func (m *LoadBalanceMutation) UpstreamHeaderTimeout() (r int, exists bool) {
	v := m.upstream_header_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldUpstreamHeaderTimeout returns the old upstream_header_timeout value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldUpstreamHeaderTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpstreamHeaderTimeout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpstreamHeaderTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpstreamHeaderTimeout: %w", err)
	}
	return oldValue.UpstreamHeaderTimeout, nil
}

// AddUpstreamHeaderTimeout adds i to upstream_header_timeout.
func (m *LoadBalanceMutation) AddUpstreamHeaderTimeout(i int) {
	if m.addupstream_header_timeout != nil {
		*m.addupstream_header_timeout += i
	} else {
		m.addupstream_header_timeout = &i
	}
}

// AddedUpstreamHeaderTimeout returns the value that was added to the upstream_header_timeout field in this mutation.
func (m *LoadBalanceMutation) AddedUpstreamHeaderTimeout() (r int, exists bool) {
	v := m.addupstream_header_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpstreamHeaderTimeout reset all changes of the "upstream_header_timeout" field.
func (m *LoadBalanceMutation) ResetUpstreamHeaderTimeout() {
	m.upstream_header_timeout = nil
	m.addupstream_header_timeout = nil
}

// SetUpstreamIdleTimeout sets the upstream_idle_timeout field.
func (m *LoadBalanceMutation) SetUpstreamIdleTimeout(i int) {
	m.upstream_idle_timeout = &i
	m.addupstream_idle_timeout = nil
}

// UpstreamIdleTimeout returns the upstream_idle_timeout value in the mutation.
func (m *LoadBalanceMutation) UpstreamIdleTimeout() (r int, exists bool) {
	v := m.upstream_idle_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldUpstreamIdleTimeout returns the old upstream_idle_timeout value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldUpstreamIdleTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpstreamIdleTimeout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpstreamIdleTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpstreamIdleTimeout: %w", err)
	}
	return oldValue.UpstreamIdleTimeout, nil
}

// AddUpstreamIdleTimeout adds i to upstream_idle_timeout.
func (m *LoadBalanceMutation) AddUpstreamIdleTimeout(i int) {
	if m.addupstream_idle_timeout != nil {
		*m.addupstream_idle_timeout += i
	} else {
		m.addupstream_idle_timeout = &i
	}
}

// AddedUpstreamIdleTimeout returns the value that was added to the upstream_idle_timeout field in this mutation.
func (m *LoadBalanceMutation) AddedUpstreamIdleTimeout() (r int, exists bool) {
	v := m.addupstream_idle_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpstreamIdleTimeout reset all changes of the "upstream_idle_timeout" field.
func (m *LoadBalanceMutation) ResetUpstreamIdleTimeout() {
	m.upstream_idle_timeout = nil
	m.addupstream_idle_timeout = nil
}

// SetUpstreamMaxIdle sets the upstream_max_idle field.
func (m *LoadBalanceMutation) SetUpstreamMaxIdle(i int) {
	m.upstream_max_idle = &i
	m.addupstream_max_idle = nil
}

// UpstreamMaxIdle returns the upstream_max_idle value in the mutation.
func (m *LoadBalanceMutation) UpstreamMaxIdle() (r int, exists bool) {
	v := m.upstream_max_idle
	if v == nil {
		return
	}
	return *v, true
}

// OldUpstreamMaxIdle returns the old upstream_max_idle value of the LoadBalance.
// If the LoadBalance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LoadBalanceMutation) OldUpstreamMaxIdle(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpstreamMaxIdle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpstreamMaxIdle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpstreamMaxIdle: %w", err)
	}
	return oldValue.UpstreamMaxIdle, nil
}

// AddUpstreamMaxIdle adds i to upstream_max_idle.
func (m *LoadBalanceMutation) AddUpstreamMaxIdle(i int) {
	if m.addupstream_max_idle != nil {
		*m.addupstream_max_idle += i
	} else {
		m.addupstream_max_idle = &i
	}
}

// AddedUpstreamMaxIdle returns the value that was added to the upstream_max_idle field in this mutation.
func (m *LoadBalanceMutation) AddedUpstreamMaxIdle() (r int, exists bool) {
	v := m.addupstream_max_idle
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpstreamMaxIdle reset all changes of the "upstream_max_idle" field.
func (m *LoadBalanceMutation) ResetUpstreamMaxIdle() {
	m.upstream_max_idle = nil
	m.addupstream_max_idle = nil
}

// Op returns the operation name.
func (m *LoadBalanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LoadBalance).
func (m *LoadBalanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LoadBalanceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.service_id != nil {
		fields = append(fields, loadbalance.FieldServiceID)
	}
	if m.check_method != nil {
		fields = append(fields, loadbalance.FieldCheckMethod)
	}
	if m.check_timeout != nil {
		fields = append(fields, loadbalance.FieldCheckTimeout)
	}
	if m.check_interval != nil {
		fields = append(fields, loadbalance.FieldCheckInterval)
	}
	if m.round_type != nil {
		fields = append(fields, loadbalance.FieldRoundType)
	}
	if m.ip_list != nil {
		fields = append(fields, loadbalance.FieldIPList)
	}
	if m.weight_list != nil {
		fields = append(fields, loadbalance.FieldWeightList)
	}
	if m.forbid_list != nil {
		fields = append(fields, loadbalance.FieldForbidList)
	}
	if m.upstream_connect_timeout != nil {
		fields = append(fields, loadbalance.FieldUpstreamConnectTimeout)
	}
	if m.upstream_header_timeout != nil {
		fields = append(fields, loadbalance.FieldUpstreamHeaderTimeout)
	}
	if m.upstream_idle_timeout != nil {
		fields = append(fields, loadbalance.FieldUpstreamIdleTimeout)
	}
	if m.upstream_max_idle != nil {
		fields = append(fields, loadbalance.FieldUpstreamMaxIdle)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LoadBalanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loadbalance.FieldServiceID:
		return m.ServiceID()
	case loadbalance.FieldCheckMethod:
		return m.CheckMethod()
	case loadbalance.FieldCheckTimeout:
		return m.CheckTimeout()
	case loadbalance.FieldCheckInterval:
		return m.CheckInterval()
	case loadbalance.FieldRoundType:
		return m.RoundType()
	case loadbalance.FieldIPList:
		return m.IPList()
	case loadbalance.FieldWeightList:
		return m.WeightList()
	case loadbalance.FieldForbidList:
		return m.ForbidList()
	case loadbalance.FieldUpstreamConnectTimeout:
		return m.UpstreamConnectTimeout()
	case loadbalance.FieldUpstreamHeaderTimeout:
		return m.UpstreamHeaderTimeout()
	case loadbalance.FieldUpstreamIdleTimeout:
		return m.UpstreamIdleTimeout()
	case loadbalance.FieldUpstreamMaxIdle:
		return m.UpstreamMaxIdle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LoadBalanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loadbalance.FieldServiceID:
		return m.OldServiceID(ctx)
	case loadbalance.FieldCheckMethod:
		return m.OldCheckMethod(ctx)
	case loadbalance.FieldCheckTimeout:
		return m.OldCheckTimeout(ctx)
	case loadbalance.FieldCheckInterval:
		return m.OldCheckInterval(ctx)
	case loadbalance.FieldRoundType:
		return m.OldRoundType(ctx)
	case loadbalance.FieldIPList:
		return m.OldIPList(ctx)
	case loadbalance.FieldWeightList:
		return m.OldWeightList(ctx)
	case loadbalance.FieldForbidList:
		return m.OldForbidList(ctx)
	case loadbalance.FieldUpstreamConnectTimeout:
		return m.OldUpstreamConnectTimeout(ctx)
	case loadbalance.FieldUpstreamHeaderTimeout:
		return m.OldUpstreamHeaderTimeout(ctx)
	case loadbalance.FieldUpstreamIdleTimeout:
		return m.OldUpstreamIdleTimeout(ctx)
	case loadbalance.FieldUpstreamMaxIdle:
		return m.OldUpstreamMaxIdle(ctx)
	}
	return nil, fmt.Errorf("unknown LoadBalance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LoadBalanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loadbalance.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case loadbalance.FieldCheckMethod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckMethod(v)
		return nil
	case loadbalance.FieldCheckTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckTimeout(v)
		return nil
	case loadbalance.FieldCheckInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInterval(v)
		return nil
	case loadbalance.FieldRoundType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundType(v)
		return nil
	case loadbalance.FieldIPList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPList(v)
		return nil
	case loadbalance.FieldWeightList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightList(v)
		return nil
	case loadbalance.FieldForbidList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForbidList(v)
		return nil
	case loadbalance.FieldUpstreamConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpstreamConnectTimeout(v)
		return nil
	case loadbalance.FieldUpstreamHeaderTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpstreamHeaderTimeout(v)
		return nil
	case loadbalance.FieldUpstreamIdleTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpstreamIdleTimeout(v)
		return nil
	case loadbalance.FieldUpstreamMaxIdle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpstreamMaxIdle(v)
		return nil
	}
	return fmt.Errorf("unknown LoadBalance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LoadBalanceMutation) AddedFields() []string {
	var fields []string
	if m.addservice_id != nil {
		fields = append(fields, loadbalance.FieldServiceID)
	}
	if m.addcheck_method != nil {
		fields = append(fields, loadbalance.FieldCheckMethod)
	}
	if m.addcheck_timeout != nil {
		fields = append(fields, loadbalance.FieldCheckTimeout)
	}
	if m.addcheck_interval != nil {
		fields = append(fields, loadbalance.FieldCheckInterval)
	}
	if m.addround_type != nil {
		fields = append(fields, loadbalance.FieldRoundType)
	}
	if m.addupstream_connect_timeout != nil {
		fields = append(fields, loadbalance.FieldUpstreamConnectTimeout)
	}
	if m.addupstream_header_timeout != nil {
		fields = append(fields, loadbalance.FieldUpstreamHeaderTimeout)
	}
	if m.addupstream_idle_timeout != nil {
		fields = append(fields, loadbalance.FieldUpstreamIdleTimeout)
	}
	if m.addupstream_max_idle != nil {
		fields = append(fields, loadbalance.FieldUpstreamMaxIdle)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LoadBalanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loadbalance.FieldServiceID:
		return m.AddedServiceID()
	case loadbalance.FieldCheckMethod:
		return m.AddedCheckMethod()
	case loadbalance.FieldCheckTimeout:
		return m.AddedCheckTimeout()
	case loadbalance.FieldCheckInterval:
		return m.AddedCheckInterval()
	case loadbalance.FieldRoundType:
		return m.AddedRoundType()
	case loadbalance.FieldUpstreamConnectTimeout:
		return m.AddedUpstreamConnectTimeout()
	case loadbalance.FieldUpstreamHeaderTimeout:
		return m.AddedUpstreamHeaderTimeout()
	case loadbalance.FieldUpstreamIdleTimeout:
		return m.AddedUpstreamIdleTimeout()
	case loadbalance.FieldUpstreamMaxIdle:
		return m.AddedUpstreamMaxIdle()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LoadBalanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loadbalance.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceID(v)
		return nil
	case loadbalance.FieldCheckMethod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckMethod(v)
		return nil
	case loadbalance.FieldCheckTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckTimeout(v)
		return nil
	case loadbalance.FieldCheckInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckInterval(v)
		return nil
	case loadbalance.FieldRoundType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundType(v)
		return nil
	case loadbalance.FieldUpstreamConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpstreamConnectTimeout(v)
		return nil
	case loadbalance.FieldUpstreamHeaderTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpstreamHeaderTimeout(v)
		return nil
	case loadbalance.FieldUpstreamIdleTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpstreamIdleTimeout(v)
		return nil
	case loadbalance.FieldUpstreamMaxIdle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpstreamMaxIdle(v)
		return nil
	}
	return fmt.Errorf("unknown LoadBalance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LoadBalanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LoadBalanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoadBalanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LoadBalance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LoadBalanceMutation) ResetField(name string) error {
	switch name {
	case loadbalance.FieldServiceID:
		m.ResetServiceID()
		return nil
	case loadbalance.FieldCheckMethod:
		m.ResetCheckMethod()
		return nil
	case loadbalance.FieldCheckTimeout:
		m.ResetCheckTimeout()
		return nil
	case loadbalance.FieldCheckInterval:
		m.ResetCheckInterval()
		return nil
	case loadbalance.FieldRoundType:
		m.ResetRoundType()
		return nil
	case loadbalance.FieldIPList:
		m.ResetIPList()
		return nil
	case loadbalance.FieldWeightList:
		m.ResetWeightList()
		return nil
	case loadbalance.FieldForbidList:
		m.ResetForbidList()
		return nil
	case loadbalance.FieldUpstreamConnectTimeout:
		m.ResetUpstreamConnectTimeout()
		return nil
	case loadbalance.FieldUpstreamHeaderTimeout:
		m.ResetUpstreamHeaderTimeout()
		return nil
	case loadbalance.FieldUpstreamIdleTimeout:
		m.ResetUpstreamIdleTimeout()
		return nil
	case loadbalance.FieldUpstreamMaxIdle:
		m.ResetUpstreamMaxIdle()
		return nil
	}
	return fmt.Errorf("unknown LoadBalance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LoadBalanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LoadBalanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LoadBalanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LoadBalanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LoadBalanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LoadBalanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LoadBalanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoadBalance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LoadBalanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoadBalance edge %s", name)
}

// ServiceMutation represents an operation that mutate the Services
// nodes in the graph.
type ServiceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	load_type     *int
	addload_type  *int
	service_name  *string
	service_desc  *string
	create_at     *time.Time
	update_at     *time.Time
	is_delete     *int8
	addis_delete  *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Service, error)
	predicates    []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows to manage the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for $n.Name.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the id field of the mutation.
func withServiceID(id int64) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Service creation.
func (m *ServiceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServiceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLoadType sets the load_type field.
func (m *ServiceMutation) SetLoadType(i int) {
	m.load_type = &i
	m.addload_type = nil
}

// LoadType returns the load_type value in the mutation.
func (m *ServiceMutation) LoadType() (r int, exists bool) {
	v := m.load_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadType returns the old load_type value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldLoadType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLoadType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLoadType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadType: %w", err)
	}
	return oldValue.LoadType, nil
}

// AddLoadType adds i to load_type.
func (m *ServiceMutation) AddLoadType(i int) {
	if m.addload_type != nil {
		*m.addload_type += i
	} else {
		m.addload_type = &i
	}
}

// AddedLoadType returns the value that was added to the load_type field in this mutation.
func (m *ServiceMutation) AddedLoadType() (r int, exists bool) {
	v := m.addload_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoadType reset all changes of the "load_type" field.
func (m *ServiceMutation) ResetLoadType() {
	m.load_type = nil
	m.addload_type = nil
}

// SetServiceName sets the service_name field.
func (m *ServiceMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the service_name value in the mutation.
func (m *ServiceMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old service_name value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName reset all changes of the "service_name" field.
func (m *ServiceMutation) ResetServiceName() {
	m.service_name = nil
}

// SetServiceDesc sets the service_desc field.
func (m *ServiceMutation) SetServiceDesc(s string) {
	m.service_desc = &s
}

// ServiceDesc returns the service_desc value in the mutation.
func (m *ServiceMutation) ServiceDesc() (r string, exists bool) {
	v := m.service_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceDesc returns the old service_desc value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldServiceDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceDesc is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceDesc: %w", err)
	}
	return oldValue.ServiceDesc, nil
}

// ResetServiceDesc reset all changes of the "service_desc" field.
func (m *ServiceMutation) ResetServiceDesc() {
	m.service_desc = nil
}

// SetCreateAt sets the create_at field.
func (m *ServiceMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the create_at value in the mutation.
func (m *ServiceMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old create_at value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt reset all changes of the "create_at" field.
func (m *ServiceMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the update_at field.
func (m *ServiceMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the update_at value in the mutation.
func (m *ServiceMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old update_at value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt reset all changes of the "update_at" field.
func (m *ServiceMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetIsDelete sets the is_delete field.
func (m *ServiceMutation) SetIsDelete(i int8) {
	m.is_delete = &i
	m.addis_delete = nil
}

// IsDelete returns the is_delete value in the mutation.
func (m *ServiceMutation) IsDelete() (r int8, exists bool) {
	v := m.is_delete
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDelete returns the old is_delete value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldIsDelete(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDelete is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDelete: %w", err)
	}
	return oldValue.IsDelete, nil
}

// AddIsDelete adds i to is_delete.
func (m *ServiceMutation) AddIsDelete(i int8) {
	if m.addis_delete != nil {
		*m.addis_delete += i
	} else {
		m.addis_delete = &i
	}
}

// AddedIsDelete returns the value that was added to the is_delete field in this mutation.
func (m *ServiceMutation) AddedIsDelete() (r int8, exists bool) {
	v := m.addis_delete
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDelete reset all changes of the "is_delete" field.
func (m *ServiceMutation) ResetIsDelete() {
	m.is_delete = nil
	m.addis_delete = nil
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.load_type != nil {
		fields = append(fields, service.FieldLoadType)
	}
	if m.service_name != nil {
		fields = append(fields, service.FieldServiceName)
	}
	if m.service_desc != nil {
		fields = append(fields, service.FieldServiceDesc)
	}
	if m.create_at != nil {
		fields = append(fields, service.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, service.FieldUpdateAt)
	}
	if m.is_delete != nil {
		fields = append(fields, service.FieldIsDelete)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldLoadType:
		return m.LoadType()
	case service.FieldServiceName:
		return m.ServiceName()
	case service.FieldServiceDesc:
		return m.ServiceDesc()
	case service.FieldCreateAt:
		return m.CreateAt()
	case service.FieldUpdateAt:
		return m.UpdateAt()
	case service.FieldIsDelete:
		return m.IsDelete()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldLoadType:
		return m.OldLoadType(ctx)
	case service.FieldServiceName:
		return m.OldServiceName(ctx)
	case service.FieldServiceDesc:
		return m.OldServiceDesc(ctx)
	case service.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case service.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case service.FieldIsDelete:
		return m.OldIsDelete(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldLoadType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadType(v)
		return nil
	case service.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case service.FieldServiceDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceDesc(v)
		return nil
	case service.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case service.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case service.FieldIsDelete:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDelete(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServiceMutation) AddedFields() []string {
	var fields []string
	if m.addload_type != nil {
		fields = append(fields, service.FieldLoadType)
	}
	if m.addis_delete != nil {
		fields = append(fields, service.FieldIsDelete)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case service.FieldLoadType:
		return m.AddedLoadType()
	case service.FieldIsDelete:
		return m.AddedIsDelete()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case service.FieldLoadType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadType(v)
		return nil
	case service.FieldIsDelete:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDelete(v)
		return nil
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldLoadType:
		m.ResetLoadType()
		return nil
	case service.FieldServiceName:
		m.ResetServiceName()
		return nil
	case service.FieldServiceDesc:
		m.ResetServiceDesc()
		return nil
	case service.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case service.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case service.FieldIsDelete:
		m.ResetIsDelete()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Service edge %s", name)
}

// TcpRuleMutation represents an operation that mutate the TcpRules
// nodes in the graph.
type TcpRuleMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	service_id    *int64
	addservice_id *int64
	_Port         *int
	add_Port      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TcpRule, error)
	predicates    []predicate.TcpRule
}

var _ ent.Mutation = (*TcpRuleMutation)(nil)

// tcpruleOption allows to manage the mutation configuration using functional options.
type tcpruleOption func(*TcpRuleMutation)

// newTcpRuleMutation creates new mutation for $n.Name.
func newTcpRuleMutation(c config, op Op, opts ...tcpruleOption) *TcpRuleMutation {
	m := &TcpRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeTcpRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTcpRuleID sets the id field of the mutation.
func withTcpRuleID(id int64) tcpruleOption {
	return func(m *TcpRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *TcpRule
		)
		m.oldValue = func(ctx context.Context) (*TcpRule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TcpRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTcpRule sets the old TcpRule of the mutation.
func withTcpRule(node *TcpRule) tcpruleOption {
	return func(m *TcpRuleMutation) {
		m.oldValue = func(context.Context) (*TcpRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TcpRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TcpRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on TcpRule creation.
func (m *TcpRuleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TcpRuleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetServiceID sets the service_id field.
func (m *TcpRuleMutation) SetServiceID(i int64) {
	m.service_id = &i
	m.addservice_id = nil
}

// ServiceID returns the service_id value in the mutation.
func (m *TcpRuleMutation) ServiceID() (r int64, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old service_id value of the TcpRule.
// If the TcpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TcpRuleMutation) OldServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// AddServiceID adds i to service_id.
func (m *TcpRuleMutation) AddServiceID(i int64) {
	if m.addservice_id != nil {
		*m.addservice_id += i
	} else {
		m.addservice_id = &i
	}
}

// AddedServiceID returns the value that was added to the service_id field in this mutation.
func (m *TcpRuleMutation) AddedServiceID() (r int64, exists bool) {
	v := m.addservice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetServiceID reset all changes of the "service_id" field.
func (m *TcpRuleMutation) ResetServiceID() {
	m.service_id = nil
	m.addservice_id = nil
}

// SetPort sets the Port field.
func (m *TcpRuleMutation) SetPort(i int) {
	m._Port = &i
	m.add_Port = nil
}

// Port returns the Port value in the mutation.
func (m *TcpRuleMutation) Port() (r int, exists bool) {
	v := m._Port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old Port value of the TcpRule.
// If the TcpRule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TcpRuleMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to Port.
func (m *TcpRuleMutation) AddPort(i int) {
	if m.add_Port != nil {
		*m.add_Port += i
	} else {
		m.add_Port = &i
	}
}

// AddedPort returns the value that was added to the Port field in this mutation.
func (m *TcpRuleMutation) AddedPort() (r int, exists bool) {
	v := m.add_Port
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort reset all changes of the "Port" field.
func (m *TcpRuleMutation) ResetPort() {
	m._Port = nil
	m.add_Port = nil
}

// Op returns the operation name.
func (m *TcpRuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TcpRule).
func (m *TcpRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TcpRuleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.service_id != nil {
		fields = append(fields, tcprule.FieldServiceID)
	}
	if m._Port != nil {
		fields = append(fields, tcprule.FieldPort)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TcpRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tcprule.FieldServiceID:
		return m.ServiceID()
	case tcprule.FieldPort:
		return m.Port()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TcpRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tcprule.FieldServiceID:
		return m.OldServiceID(ctx)
	case tcprule.FieldPort:
		return m.OldPort(ctx)
	}
	return nil, fmt.Errorf("unknown TcpRule field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TcpRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tcprule.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case tcprule.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	}
	return fmt.Errorf("unknown TcpRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TcpRuleMutation) AddedFields() []string {
	var fields []string
	if m.addservice_id != nil {
		fields = append(fields, tcprule.FieldServiceID)
	}
	if m.add_Port != nil {
		fields = append(fields, tcprule.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TcpRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tcprule.FieldServiceID:
		return m.AddedServiceID()
	case tcprule.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TcpRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tcprule.FieldServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceID(v)
		return nil
	case tcprule.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown TcpRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TcpRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TcpRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TcpRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TcpRule nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TcpRuleMutation) ResetField(name string) error {
	switch name {
	case tcprule.FieldServiceID:
		m.ResetServiceID()
		return nil
	case tcprule.FieldPort:
		m.ResetPort()
		return nil
	}
	return fmt.Errorf("unknown TcpRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TcpRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TcpRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TcpRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TcpRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TcpRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TcpRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TcpRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TcpRule unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TcpRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TcpRule edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	salt          *string
	password      *string
	update_at     *time.Time
	create_at     *time.Time
	is_delete     *int
	addis_delete  *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on User creation.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the username field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the username value in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old username value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername reset all changes of the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetSalt sets the salt field.
func (m *UserMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the salt value in the mutation.
func (m *UserMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old salt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt reset all changes of the "salt" field.
func (m *UserMutation) ResetSalt() {
	m.salt = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetUpdateAt sets the update_at field.
func (m *UserMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the update_at value in the mutation.
func (m *UserMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old update_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt reset all changes of the "update_at" field.
func (m *UserMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetCreateAt sets the create_at field.
func (m *UserMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the create_at value in the mutation.
func (m *UserMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old create_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt reset all changes of the "create_at" field.
func (m *UserMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetIsDelete sets the is_delete field.
func (m *UserMutation) SetIsDelete(i int) {
	m.is_delete = &i
	m.addis_delete = nil
}

// IsDelete returns the is_delete value in the mutation.
func (m *UserMutation) IsDelete() (r int, exists bool) {
	v := m.is_delete
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDelete returns the old is_delete value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldIsDelete(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDelete is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDelete: %w", err)
	}
	return oldValue.IsDelete, nil
}

// AddIsDelete adds i to is_delete.
func (m *UserMutation) AddIsDelete(i int) {
	if m.addis_delete != nil {
		*m.addis_delete += i
	} else {
		m.addis_delete = &i
	}
}

// AddedIsDelete returns the value that was added to the is_delete field in this mutation.
func (m *UserMutation) AddedIsDelete() (r int, exists bool) {
	v := m.addis_delete
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDelete reset all changes of the "is_delete" field.
func (m *UserMutation) ResetIsDelete() {
	m.is_delete = nil
	m.addis_delete = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.salt != nil {
		fields = append(fields, user.FieldSalt)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.update_at != nil {
		fields = append(fields, user.FieldUpdateAt)
	}
	if m.create_at != nil {
		fields = append(fields, user.FieldCreateAt)
	}
	if m.is_delete != nil {
		fields = append(fields, user.FieldIsDelete)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldSalt:
		return m.Salt()
	case user.FieldPassword:
		return m.Password()
	case user.FieldUpdateAt:
		return m.UpdateAt()
	case user.FieldCreateAt:
		return m.CreateAt()
	case user.FieldIsDelete:
		return m.IsDelete()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldSalt:
		return m.OldSalt(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case user.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case user.FieldIsDelete:
		return m.OldIsDelete(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case user.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case user.FieldIsDelete:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDelete(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addis_delete != nil {
		fields = append(fields, user.FieldIsDelete)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldIsDelete:
		return m.AddedIsDelete()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldIsDelete:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDelete(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldSalt:
		m.ResetSalt()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case user.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case user.FieldIsDelete:
		m.ResetIsDelete()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
